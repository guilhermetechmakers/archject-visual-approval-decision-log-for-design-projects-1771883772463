⚠️ CRITICAL EXECUTION RULES - READ FIRST ⚠️
❌ NEVER run: npm run dev, npm start, yarn dev, pnpm dev, or ANY development server
❌ NEVER run: long-running processes, servers, or commands that don't exit
❌ NEVER test the application by starting it
✅ ALLOWED: npm install, npm run build, npm run test (if needed)
✅ YOUR TASK: Create/modify files only, then STOP and EXIT immediately
⚠️ The MCP server handles all testing and validation separately

You are an expert full-stack developer proficient in TypeScript, React, Next.js, and modern UI/UX frameworks (Tailwind CSS, Shadcn UI, Radix UI).

=== DESIGN REFERENCE (MANDATORY) ===
# Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions


---

# Project-Specific Customizations

**IMPORTANT: This section contains the specific design requirements for THIS project. The guidelines above are universal best practices - these customizations below take precedence for project-specific decisions.**

## User Design Requirements

Client Portal and Internal Decision Detail.
  - Card-based, grid layouts, accessible components, responsive behavior (mobile-first).
  - Inline media annotation tools with zoom/pan, scrubber for media timeline (if applicable).
  - Rich text input with mention suggestions, emoji support optional.

---

## Implementation Requirements

### Frontend
- Build a cohesive design system-aligned UI:
  - Reusable React/Vue/Svelte components (Card, Button, Input, Tag, Tabs, MediaViewer, AnnotationOverlay, CommentThread).
  - MediaAnnotationOverlay component capable of rendering shapes, showing metadata, and allowing edits by authorized users.
  - CommentThread component with nested replies, edit/delete windows, mention highlighting, and inline actions (edit, delete, resolve).
  - Side-by-side OptionComparison component: responsive grid that adapts to viewport; shows media, specs, cost, and decision notes per option.
  - Real-time update indicators (typing, new comments, annotation changes).

- Pages:
  - Client Portal (No-login Link):
    - Route: /client-portal/:decisionToken
    - Features: authentication via token, side-by-side comparison, comment composer with mentions, annotation-capable media, approve/change-request actions, optional OTP flow.
  - Decision Detail (Internal):
    - Route: /internal/decisions/:decisionId
    - Features: full decision data, option-by-option annotations, audit trail, export controls, moderation tools, admin actions.

- Accessibility:
  - ARIA roles, keyboard navigable, proper focus management, readable contrast (WCAG 2.1 AA).

- Internationalization:
  - Prepare for i18n (text keys, date/number localization) if needed.

- Performance:
  - Lazy loading of options/media, pagination for comments, efficient annotation rendering for large media.
  - Debounced input for comment typing, optimistic UI updates.

- Mobile-first considerations:
  - Stacked layout with collapsible sections, touch-friendly controls, and large tap targets.

- Testing:
  - Unit tests for models and services, integration tests for end-to-end comment flow, WebSocket events, and export generation.

### Backend
- Data Models (SQL/NoSQL as appropriate):
  - User: id, name, email, role, preferences.
  - Project: id, name, branding tokens, default settings.
  - Decision: id, project_id, title, status (pending/approved/revoked/needs_changes), created_at, updated_at, approved_by, approved_at, revoked_at.
  - Option: id, decision_id, title, description, media_ids, specs, price, comparison_rank.
  - Media: id, asset_url, type (image/pdf/3d), media_metadata, linked_annotations (array of annotation_ids).
  - Annotation: id, media_id, option_id (nullable), shape_type (point/rect/polygon), coordinates (JSON), created_by, created_at, updated_by, updated_at, note.
  - Comment: id, decision_id, option_id (nullable), parent_id (nullable for threading), author_id, text, mentions (array of user_ids), created_at, updated_at, edited_by, edited_at, status (active/edited/deleted).
  - Notification: id, user_id, type (mention/comment/approval), reference_id, read_at, created_at.
  - ApprovalHistory: id, decision_id, user_id, action (created/approved/rejected/edited), timestamp, details (JSON).
  - Export: id, decision_id, type (pdf/json/csv), generated_at, url.

- APIs (REST or GraphQL):
  - Decisions
    - GET /api/decisions/{id}
    - POST /api/decisions
    - PUT /api/decisions/{id}
    - POST /api/decisions/{id}/approve
    - POST /api/decisions/{id}/revoke
    - GET /api/decisions/{id}/export
  - Options
    - GET /api/decisions/{id}/options
    - POST /api/decisions/{id}/options
  - Media-Annotations
    - POST /api/media/{media_id}/annotations
    - PUT /api/annotations/{id}
    - DELETE /api/annotations/{id}
    - GET /api/media/{media_id}/annotations
  - Comments
    - GET /api/decisions/{id}/comments
    - POST /api/decisions/{id}/comments
    - PUT /api/comments/{id}
    - DELETE /api/comments/{id}
  - Mentions & Notifications
    - POST /api/notifications/mention
    - GET /api/notifications?user_id=...
  - Real-time
    - WebSocket channel endpoints for /ws/decisions/{decisionId}
  - Exports
    - GET /api/exports/{export_id}
  - Auth
    - OAuth2 / JWT-based authentication; token validation; role checks.

- Database indexing and constraints:
  - Index on decision_id for comments, annotations; index on media_id; composite indexes for option and decision lookups.
  - Foreign keys: decision -> project; option -> decision; annotation -> media/option; comment -> decision/option/parent; notification -> user.

- Real-time & Messaging:
  - WebSocket channels per decision for comments and annotation updates.
  - Fallback to long-polling if WebSockets unavailable.
  - Debounce rapid comment streams; ensure at-least-once delivery semantics.

- Security:
  - No-login access tokens for client portal with expiration; token rotation.
  - Server-side validation for all inputs; server-side enforcement of business rules (e.g., cannot approve after revoke).
  - Rate limiting on comment POSTs and OTP validation; detect and mitigate abuse.

- Data Integrity & Auditing:
  - Immutable audit entries for approvals and edits; versioning for comments and annotations (with delta diffs if feasible).
  - Export exports reproduce exact state snapshots with timestamps.

### Integration
- Client Portal and Internal Decision Detail both consume the same backend APIs:
  - Shared data models for decisions, options, media, comments, and annotations.
  - Client Portal uses a token-based access path with read/write scoped permissions; Limited comment actions, no admin controls.
  - Internal view uses full permissions (create/edit/delete, export, revoke).

- Branding & Theming:
  - Centralized design tokens for colors, font sizes, spacing, radii.
  - Components should adapt to the brand’s palette and be override-ready for client-specific branding.

- Error Handling:
  - Consistent error payload structure; user-friendly messages; telemetry hooks for errors.

---

## User Experience Flow

1) Client Portal (No-login Link)
- Client opens a shareable link to a decision with side-by-side options.
- Client views media and option details; annotations are visible and can be added by authorized clients if permitted.
- Client adds a comment, optionally mentioning internal team members. Comment appears in real-time or near real-time.
- Client annotates media coordinates to indicate preferences or concerns (where allowed).
- Client can approve or request changes, optionally leaving a short note; action triggers a notification to internal stakeholders.
- If OTP/verification is enabled:
  - Client enters email (if captured) or phone to receive an OTP.
  - Client enters OTP to validate before submitting approval or comments beyond a basic level.
- Notifications: when a new comment or mention appears, the client gets a notification via the chosen channel.

2) Internal Decision Detail (Admin)
- Internal user logs in to /internal/decisions/{decisionId}.
- See the decision overview with status, timestamps, and approval history.
- Open each option to view side-by-side comparisons, related media, and inline annotations.
- View and reply to comments; edit or delete comments within allowed windows; resolve comments if applicable.
- Add annotations to media; modify existing annotations or create new ones; link annotations to specific options if needed.
- Admin actions:
  - Edit decision details, revise option data, or adjust approvals.
  - Revoke approvals with rationale; log revoke reason in ApprovalHistory.
  - Export decision logs to PDF/JSON/CSV; download or share export URL.
- Real-time updates ensure parallel editors see changes instantly.

3) Notifications & Mentions
- Mentions trigger in-app notifications; mention recipients are auto-tagged and alerted.
- Clients and internal users receive notifications about:
  - New comments, replies, or annotations.
  - Status changes (approved, changes requested, revoked).
  - Mentions and upcoming deadlines/reminders.

4) Moderation
- Moderators can edit/delete inappropriate content within allowed windows.
- Moderation logs captured with user and timestamp.

---

## Technical Specifications

- Data Models: (schemas summarized)
  - User: id, name, email, role (client/internal/admin), preferences.
  - Project: id, name, brandingTokens.
  - Decision: id, project_id, title, status enum, created_at, updated_at, approved_by_id, approved_at, revocation_reason.
  - Option: id, decision_id, title, description, specs, media_ids, price, rank.
  - Media: id, asset_url, type, metadata JSON, linked_annotation_ids.
  - Annotation: id, media_id, option_id (nullable), shape_type (enum: point/rect/polygon), coordinates JSON, note, created_by_id, created_at, updated_by_id, updated_at.
  - Comment: id, decision_id, option_id, parent_id, author_id, text, mentions JSON, created_at, updated_at, status (active/edited/deleted).
  - Notification: id, user_id, type (mention/comment/approval), reference_id, read_at, created_at.
  - ApprovalHistory: id, decision_id, user_id, action (created/approved/rejected/revoked/edited), timestamp, details JSON.
  - Export: id, decision_id, type (pdf/json/csv), generated_at, url.

- API Endpoints (examples; use your tech preference):
  - GET /api/decisions/{decisionId}
  - POST /api/decisions
  - PUT /api/decisions/{decisionId}
  - POST /api/decisions/{decisionId}/approve
  - POST /api/decisions/{decisionId}/revoke
  - GET /api/decisions/{decisionId}/export
  - GET /api/decisions/{decisionId}/options
  - POST /api/decisions/{decisionId}/options
  - GET /api/decisions/{decisionId}/comments
  - POST /api/decisions/{decisionId}/comments
  - PUT /api/comments/{commentId}
  - DELETE /api/comments/{commentId}
  - POST /api/media/{mediaId}/annotations
  - PUT /api/annotations/{annotationId}
  - GET /api/media/{mediaId}/annotations
  - GET /ws/decisions/{decisionId} for real-time events (WebSocket)

- Security:
  - JWT/OAuth2 for internal endpoints; tokenized, single-use or time-limited access tokens for client portal.
  - Scopes: client:view, client:comment, client:annotate, internal:admin, internal:comment, internal:export.
  - Input validation, CSRF protection for REST routes; rate-limiting on comment posting and OTP requests.
  - Data encryption at rest for sensitive fields (e.g., revocation reasons, notes).

- Validation:
  - Mandatory fields: decision title, option title, at least one media reference for annotation, non-empty comment text (trimmed).
  - Annotations: coordinates must be valid JSON per shape_type; coordinates within media bounds.
  - OTP flow: OTP length, expiry, retry limits, and verification result handling.

- Real-time & Offline:
  - Implement WebSocket-based updates with reconnection logic; fallback to long-polling if necessary.
  - Optimistic UI updates for new comments and annotations with reconciliation on server ack.

- Data Ownership & Export:
  - Exports must contain versioned data snapshots; include audit trail and asset references; respect data retention policies.

---

## Acceptance Criteria
- [ ] Real-time comments and annotations propagate to all connected clients/viewers within 1-2 seconds of creation.
- [ ] Threaded comments support multi-level replies; edit/delete is available within defined time window; moderation actions are auditable.
- [ ] Annotations render accurately on all media types (image, PDF page, etc.) with correct coordinate mapping; shapes are editable by authorized users and persist correctly.
- [ ] Client Portal link functions without login, with OTP verification if enabled; OTP flow is secure, rate-limited, and expires.
- [ ] Internal Decision Detail shows side-by-side comparison with the ability to annotate, comment, view approval history, and perform export actions.
- [ ] Exports (PDF/JSON/CSV) accurately reflect current decision state, including annotations and media references.
- [ ] Security: unauthorized access is prevented; client portal links cannot be abused to access other decisions; all endpoints enforce proper scopes.
- [ ] Accessibility and responsive behavior tested across desktop and mobile.

---

## UI/UX Guidelines

Apply Archject’s design system and branding:
- Cards with white background, soft shadows, rounded corners, and generous padding.
- Navigation: top bar with pill-shaped tabs; active state in #195C4A; white text on active tabs.
- Layout: wide, airy grid; 8px spacing increments; 24-32px container padding; left-aligned content with strong vertical rhythm.
- Data Visuals: clean charts with subtle grids; status badges in green/yellow/red; tooltips on hover.
- Interactive Elements: pill-shaped buttons; primary actions in deep green (#195C4A); hover states with subtle shadows; inputs with light background (#F5F6FA) and clear focus rings.
- Typography: Inter/Manrope/SF Pro family; weights 400 (body), 500 (labels/navigation), 600 (headings/actions).
- Mobile-first: touch targets, collapsible sections, responsive side-by-side to stacked flows.

Visual references:
- Card elevation: 0 4px 16px rgba(34, 42, 89, 0.05)
- Backgrounds: #FFFFFF (cards), #F5F6FA/#F7F8FA (surfaces)
- Text: #23272F (primary), #6B7280 (secondary)

---

## Final Deliverables

- Fully wired frontend (Client Portal and Internal Decision Detail) with reusable components and theming hooks.
- Backend services with models, APIs, WebSocket channels, and database migrations.
- Documentation:
  - API docs with endpoints, request/response schemas, and sample payloads.
  - Data model diagrams (ERD) and flowcharts for comment/annotation lifecycle.
  - Developer guide for extending annotations, workflows, and export formats.
- Test suite:
  - Unit tests for models and services.
  - Integration tests for critical flows: commenting, threading, annotations, real-time updates, OTP verification, and export.
- Deployment guidance:
  - Environment variables, secrets management, and migration strategies.
  - Observability: logging, metrics, and alerting setup for real-time events.

---

If you want, I can tailor this prompt further to your tech stack (e.g., Node.js + NestJS vs. Django, React vs. Vue, PostgreSQL vs. MongoDB) or provide a concrete API contract with JSON schemas and example payloads.

## Implementation Notes

When implementing this project:

1. **Follow Universal Guidelines**: Use the design best practices documented above as your foundation
2. **Apply Project Customizations**: Implement the specific design requirements stated in the "User Design Requirements" section
3. **Priority Order**: Project-specific requirements override universal guidelines when there's a conflict
4. **Color System**: Extract and implement color values as CSS custom properties in RGB format
5. **Typography**: Define font families, sizes, and weights based on specifications
6. **Spacing**: Establish consistent spacing scale following the design system
7. **Components**: Style all Shadcn components to match the design aesthetic
8. **Animations**: Use Motion library for transitions matching the design personality
9. **Responsive Design**: Ensure mobile-first responsive implementation

## Implementation Checklist

- [ ] Review universal design guidelines above
- [ ] Extract project-specific color palette and define CSS variables
- [ ] Configure Tailwind theme with custom colors
- [ ] Set up typography system (fonts, sizes, weights)
- [ ] Define spacing and sizing scales
- [ ] Create component variants matching design
- [ ] Implement responsive breakpoints
- [ ] Add animations and transitions
- [ ] Ensure accessibility standards
- [ ] Validate against user design requirements

---

**Remember: Always reference this file for design decisions. Do not use generic or placeholder designs.**


*IMPORTANT*: For every page or component refer to # Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions


---

# Project-Specific Customizations

**IMPORTANT: This section contains the specific design requirements for THIS project. The guidelines above are universal best practices - these customizations below take precedence for project-specific decisions.**

## User Design Requirements

Client Portal and Internal Decision Detail.
  - Card-based, grid layouts, accessible components, responsive behavior (mobile-first).
  - Inline media annotation tools with zoom/pan, scrubber for media timeline (if applicable).
  - Rich text input with mention suggestions, emoji support optional.

---

## Implementation Requirements

### Frontend
- Build a cohesive design system-aligned UI:
  - Reusable React/Vue/Svelte components (Card, Button, Input, Tag, Tabs, MediaViewer, AnnotationOverlay, CommentThread).
  - MediaAnnotationOverlay component capable of rendering shapes, showing metadata, and allowing edits by authorized users.
  - CommentThread component with nested replies, edit/delete windows, mention highlighting, and inline actions (edit, delete, resolve).
  - Side-by-side OptionComparison component: responsive grid that adapts to viewport; shows media, specs, cost, and decision notes per option.
  - Real-time update indicators (typing, new comments, annotation changes).

- Pages:
  - Client Portal (No-login Link):
    - Route: /client-portal/:decisionToken
    - Features: authentication via token, side-by-side comparison, comment composer with mentions, annotation-capable media, approve/change-request actions, optional OTP flow.
  - Decision Detail (Internal):
    - Route: /internal/decisions/:decisionId
    - Features: full decision data, option-by-option annotations, audit trail, export controls, moderation tools, admin actions.

- Accessibility:
  - ARIA roles, keyboard navigable, proper focus management, readable contrast (WCAG 2.1 AA).

- Internationalization:
  - Prepare for i18n (text keys, date/number localization) if needed.

- Performance:
  - Lazy loading of options/media, pagination for comments, efficient annotation rendering for large media.
  - Debounced input for comment typing, optimistic UI updates.

- Mobile-first considerations:
  - Stacked layout with collapsible sections, touch-friendly controls, and large tap targets.

- Testing:
  - Unit tests for models and services, integration tests for end-to-end comment flow, WebSocket events, and export generation.

### Backend
- Data Models (SQL/NoSQL as appropriate):
  - User: id, name, email, role, preferences.
  - Project: id, name, branding tokens, default settings.
  - Decision: id, project_id, title, status (pending/approved/revoked/needs_changes), created_at, updated_at, approved_by, approved_at, revoked_at.
  - Option: id, decision_id, title, description, media_ids, specs, price, comparison_rank.
  - Media: id, asset_url, type (image/pdf/3d), media_metadata, linked_annotations (array of annotation_ids).
  - Annotation: id, media_id, option_id (nullable), shape_type (point/rect/polygon), coordinates (JSON), created_by, created_at, updated_by, updated_at, note.
  - Comment: id, decision_id, option_id (nullable), parent_id (nullable for threading), author_id, text, mentions (array of user_ids), created_at, updated_at, edited_by, edited_at, status (active/edited/deleted).
  - Notification: id, user_id, type (mention/comment/approval), reference_id, read_at, created_at.
  - ApprovalHistory: id, decision_id, user_id, action (created/approved/rejected/edited), timestamp, details (JSON).
  - Export: id, decision_id, type (pdf/json/csv), generated_at, url.

- APIs (REST or GraphQL):
  - Decisions
    - GET /api/decisions/{id}
    - POST /api/decisions
    - PUT /api/decisions/{id}
    - POST /api/decisions/{id}/approve
    - POST /api/decisions/{id}/revoke
    - GET /api/decisions/{id}/export
  - Options
    - GET /api/decisions/{id}/options
    - POST /api/decisions/{id}/options
  - Media-Annotations
    - POST /api/media/{media_id}/annotations
    - PUT /api/annotations/{id}
    - DELETE /api/annotations/{id}
    - GET /api/media/{media_id}/annotations
  - Comments
    - GET /api/decisions/{id}/comments
    - POST /api/decisions/{id}/comments
    - PUT /api/comments/{id}
    - DELETE /api/comments/{id}
  - Mentions & Notifications
    - POST /api/notifications/mention
    - GET /api/notifications?user_id=...
  - Real-time
    - WebSocket channel endpoints for /ws/decisions/{decisionId}
  - Exports
    - GET /api/exports/{export_id}
  - Auth
    - OAuth2 / JWT-based authentication; token validation; role checks.

- Database indexing and constraints:
  - Index on decision_id for comments, annotations; index on media_id; composite indexes for option and decision lookups.
  - Foreign keys: decision -> project; option -> decision; annotation -> media/option; comment -> decision/option/parent; notification -> user.

- Real-time & Messaging:
  - WebSocket channels per decision for comments and annotation updates.
  - Fallback to long-polling if WebSockets unavailable.
  - Debounce rapid comment streams; ensure at-least-once delivery semantics.

- Security:
  - No-login access tokens for client portal with expiration; token rotation.
  - Server-side validation for all inputs; server-side enforcement of business rules (e.g., cannot approve after revoke).
  - Rate limiting on comment POSTs and OTP validation; detect and mitigate abuse.

- Data Integrity & Auditing:
  - Immutable audit entries for approvals and edits; versioning for comments and annotations (with delta diffs if feasible).
  - Export exports reproduce exact state snapshots with timestamps.

### Integration
- Client Portal and Internal Decision Detail both consume the same backend APIs:
  - Shared data models for decisions, options, media, comments, and annotations.
  - Client Portal uses a token-based access path with read/write scoped permissions; Limited comment actions, no admin controls.
  - Internal view uses full permissions (create/edit/delete, export, revoke).

- Branding & Theming:
  - Centralized design tokens for colors, font sizes, spacing, radii.
  - Components should adapt to the brand’s palette and be override-ready for client-specific branding.

- Error Handling:
  - Consistent error payload structure; user-friendly messages; telemetry hooks for errors.

---

## User Experience Flow

1) Client Portal (No-login Link)
- Client opens a shareable link to a decision with side-by-side options.
- Client views media and option details; annotations are visible and can be added by authorized clients if permitted.
- Client adds a comment, optionally mentioning internal team members. Comment appears in real-time or near real-time.
- Client annotates media coordinates to indicate preferences or concerns (where allowed).
- Client can approve or request changes, optionally leaving a short note; action triggers a notification to internal stakeholders.
- If OTP/verification is enabled:
  - Client enters email (if captured) or phone to receive an OTP.
  - Client enters OTP to validate before submitting approval or comments beyond a basic level.
- Notifications: when a new comment or mention appears, the client gets a notification via the chosen channel.

2) Internal Decision Detail (Admin)
- Internal user logs in to /internal/decisions/{decisionId}.
- See the decision overview with status, timestamps, and approval history.
- Open each option to view side-by-side comparisons, related media, and inline annotations.
- View and reply to comments; edit or delete comments within allowed windows; resolve comments if applicable.
- Add annotations to media; modify existing annotations or create new ones; link annotations to specific options if needed.
- Admin actions:
  - Edit decision details, revise option data, or adjust approvals.
  - Revoke approvals with rationale; log revoke reason in ApprovalHistory.
  - Export decision logs to PDF/JSON/CSV; download or share export URL.
- Real-time updates ensure parallel editors see changes instantly.

3) Notifications & Mentions
- Mentions trigger in-app notifications; mention recipients are auto-tagged and alerted.
- Clients and internal users receive notifications about:
  - New comments, replies, or annotations.
  - Status changes (approved, changes requested, revoked).
  - Mentions and upcoming deadlines/reminders.

4) Moderation
- Moderators can edit/delete inappropriate content within allowed windows.
- Moderation logs captured with user and timestamp.

---

## Technical Specifications

- Data Models: (schemas summarized)
  - User: id, name, email, role (client/internal/admin), preferences.
  - Project: id, name, brandingTokens.
  - Decision: id, project_id, title, status enum, created_at, updated_at, approved_by_id, approved_at, revocation_reason.
  - Option: id, decision_id, title, description, specs, media_ids, price, rank.
  - Media: id, asset_url, type, metadata JSON, linked_annotation_ids.
  - Annotation: id, media_id, option_id (nullable), shape_type (enum: point/rect/polygon), coordinates JSON, note, created_by_id, created_at, updated_by_id, updated_at.
  - Comment: id, decision_id, option_id, parent_id, author_id, text, mentions JSON, created_at, updated_at, status (active/edited/deleted).
  - Notification: id, user_id, type (mention/comment/approval), reference_id, read_at, created_at.
  - ApprovalHistory: id, decision_id, user_id, action (created/approved/rejected/revoked/edited), timestamp, details JSON.
  - Export: id, decision_id, type (pdf/json/csv), generated_at, url.

- API Endpoints (examples; use your tech preference):
  - GET /api/decisions/{decisionId}
  - POST /api/decisions
  - PUT /api/decisions/{decisionId}
  - POST /api/decisions/{decisionId}/approve
  - POST /api/decisions/{decisionId}/revoke
  - GET /api/decisions/{decisionId}/export
  - GET /api/decisions/{decisionId}/options
  - POST /api/decisions/{decisionId}/options
  - GET /api/decisions/{decisionId}/comments
  - POST /api/decisions/{decisionId}/comments
  - PUT /api/comments/{commentId}
  - DELETE /api/comments/{commentId}
  - POST /api/media/{mediaId}/annotations
  - PUT /api/annotations/{annotationId}
  - GET /api/media/{mediaId}/annotations
  - GET /ws/decisions/{decisionId} for real-time events (WebSocket)

- Security:
  - JWT/OAuth2 for internal endpoints; tokenized, single-use or time-limited access tokens for client portal.
  - Scopes: client:view, client:comment, client:annotate, internal:admin, internal:comment, internal:export.
  - Input validation, CSRF protection for REST routes; rate-limiting on comment posting and OTP requests.
  - Data encryption at rest for sensitive fields (e.g., revocation reasons, notes).

- Validation:
  - Mandatory fields: decision title, option title, at least one media reference for annotation, non-empty comment text (trimmed).
  - Annotations: coordinates must be valid JSON per shape_type; coordinates within media bounds.
  - OTP flow: OTP length, expiry, retry limits, and verification result handling.

- Real-time & Offline:
  - Implement WebSocket-based updates with reconnection logic; fallback to long-polling if necessary.
  - Optimistic UI updates for new comments and annotations with reconciliation on server ack.

- Data Ownership & Export:
  - Exports must contain versioned data snapshots; include audit trail and asset references; respect data retention policies.

---

## Acceptance Criteria
- [ ] Real-time comments and annotations propagate to all connected clients/viewers within 1-2 seconds of creation.
- [ ] Threaded comments support multi-level replies; edit/delete is available within defined time window; moderation actions are auditable.
- [ ] Annotations render accurately on all media types (image, PDF page, etc.) with correct coordinate mapping; shapes are editable by authorized users and persist correctly.
- [ ] Client Portal link functions without login, with OTP verification if enabled; OTP flow is secure, rate-limited, and expires.
- [ ] Internal Decision Detail shows side-by-side comparison with the ability to annotate, comment, view approval history, and perform export actions.
- [ ] Exports (PDF/JSON/CSV) accurately reflect current decision state, including annotations and media references.
- [ ] Security: unauthorized access is prevented; client portal links cannot be abused to access other decisions; all endpoints enforce proper scopes.
- [ ] Accessibility and responsive behavior tested across desktop and mobile.

---

## UI/UX Guidelines

Apply Archject’s design system and branding:
- Cards with white background, soft shadows, rounded corners, and generous padding.
- Navigation: top bar with pill-shaped tabs; active state in #195C4A; white text on active tabs.
- Layout: wide, airy grid; 8px spacing increments; 24-32px container padding; left-aligned content with strong vertical rhythm.
- Data Visuals: clean charts with subtle grids; status badges in green/yellow/red; tooltips on hover.
- Interactive Elements: pill-shaped buttons; primary actions in deep green (#195C4A); hover states with subtle shadows; inputs with light background (#F5F6FA) and clear focus rings.
- Typography: Inter/Manrope/SF Pro family; weights 400 (body), 500 (labels/navigation), 600 (headings/actions).
- Mobile-first: touch targets, collapsible sections, responsive side-by-side to stacked flows.

Visual references:
- Card elevation: 0 4px 16px rgba(34, 42, 89, 0.05)
- Backgrounds: #FFFFFF (cards), #F5F6FA/#F7F8FA (surfaces)
- Text: #23272F (primary), #6B7280 (secondary)

---

## Final Deliverables

- Fully wired frontend (Client Portal and Internal Decision Detail) with reusable components and theming hooks.
- Backend services with models, APIs, WebSocket channels, and database migrations.
- Documentation:
  - API docs with endpoints, request/response schemas, and sample payloads.
  - Data model diagrams (ERD) and flowcharts for comment/annotation lifecycle.
  - Developer guide for extending annotations, workflows, and export formats.
- Test suite:
  - Unit tests for models and services.
  - Integration tests for critical flows: commenting, threading, annotations, real-time updates, OTP verification, and export.
- Deployment guidance:
  - Environment variables, secrets management, and migration strategies.
  - Observability: logging, metrics, and alerting setup for real-time events.

---

If you want, I can tailor this prompt further to your tech stack (e.g., Node.js + NestJS vs. Django, React vs. Vue, PostgreSQL vs. MongoDB) or provide a concrete API contract with JSON schemas and example payloads.

## Implementation Notes

When implementing this project:

1. **Follow Universal Guidelines**: Use the design best practices documented above as your foundation
2. **Apply Project Customizations**: Implement the specific design requirements stated in the "User Design Requirements" section
3. **Priority Order**: Project-specific requirements override universal guidelines when there's a conflict
4. **Color System**: Extract and implement color values as CSS custom properties in RGB format
5. **Typography**: Define font families, sizes, and weights based on specifications
6. **Spacing**: Establish consistent spacing scale following the design system
7. **Components**: Style all Shadcn components to match the design aesthetic
8. **Animations**: Use Motion library for transitions matching the design personality
9. **Responsive Design**: Ensure mobile-first responsive implementation

## Implementation Checklist

- [ ] Review universal design guidelines above
- [ ] Extract project-specific color palette and define CSS variables
- [ ] Configure Tailwind theme with custom colors
- [ ] Set up typography system (fonts, sizes, weights)
- [ ] Define spacing and sizing scales
- [ ] Create component variants matching design
- [ ] Implement responsive breakpoints
- [ ] Add animations and transitions
- [ ] Ensure accessibility standards
- [ ] Validate against user design requirements

---

**Remember: Always reference this file for design decisions. Do not use generic or placeholder designs.**
 for bestpractices and # Decision Log Exports (PDF/CSV)

## Overview
Build a comprehensive Decision Log Exports feature set for Archject that enables exporting structured, branded decision logs. Exports must support:
- Human-readable, branded PDFs generated server-side via DocRaptor or Puppeteer
- Machine-readable CSV and JSON exports
- Attachments references and related metadata (decisions, options, comments, approvals, and file references)
- Preflight/export job queue with progress tracking and retry handling
- Access-controlled storage of export artifacts in S3
- Optional inclusion of digital-signature metadata for legal/export packs
- Integration with internal pages: Decision Detail (Internal), Project Workspace Page, and a generic Operation Success Page/Modal

This prompt is intended for an AI development tool to generate, scaffold, and implement the feature end-to-end with concrete artifacts (data models, APIs, UI components, workflows, tests, and integration details) aligned to the Archject design system and project context.

---

## Components to Build

1) [feature] Decision Log Exports (PDF/CSV)
- Purpose: Produce export artifacts for decisions and their context, consumable by clients and auditors.
- Outputs:
  - PDF: Branded, print-ready document with header/footer, page numbers, and optional digital-signature block.
  - CSV: Flat, machine-readable rows with normalized fields for programmatic consumption.
  - JSON: Structured export payload for API consumers or downstream systems.
- Contents:
  - Decision data: id, title, description, status, timestamps
  - Options: option_id, text, rationale, decision outcome per option
  - Comments/annotations: user, timestamp, content, mentions
  - Approvals: approver, role, status, timestamp, notes
  - Attached files references: file_id, file_name, type, URL/unsigned S3 key, references to related decisions/options
  - Metadata: project_id, decision_group, branding/version, export_timestamp, export_version
  - Optional: digital signatures metadata (signatory, certificate, timestamp, hash)
  - Audit trail entries (optional per design): action, actor, timestamp
- Performance/scale:
  - Support small (10-50 decisions) to large (1000+ decisions) export packs
  - Streaming/chunked generation for large PDFs
- Accessibility and localization: support en-US by default, ready for i18n

2) [api] DocRaptor / Puppeteer (PDF Generation)
- Purpose: Server-side rendering of branded PDFs from HTML templates or render engine output.
- Features:
  - Templating hooks for header/footer with branding ( logo, client name, project, page numbers, date)
  - Styles compatible with CSS-in-JS or external stylesheets
  - Control over page size, margins, orientation
  - Support for images/attachments, embedded charts (rendered as images)
  - Options for digital signature block and legal disclaimers
  - Retry logic and queue integration for reliability
  - Separate endpoints for initiating export, status checks, and retrieving artifact URL
- Implementation choices:
  - Prefer DocRaptor for simpler API or Puppeteer for full control; abstract behind a PDFGenerator service with pluggable backends
- Security:
  - Ensure PDFs are generated in a secure, isolated environment; enforce access controls to export artifacts

3) [page] Decision Detail (Internal)
- Purpose: Rich, internal view to review a decision and its lifecycle
- Features:
  - Display decision with all options side-by-side (comparison)
  - Show comments/annotations with threaded replies and @mentions
  - Show approval history (who approved when, status)
  - Admin actions: edit decision, revoke approval, export (PDF/CSV/JSON), add comment
  - Download/export triggers (asynchronous) with progress indicators
  - Inline editing for decision fields (title, description) with autosave or explicit save
  - Attachments panel with file references and actions (view, download)
  - Keyboard shortcuts for power users
- Data presentation:
  - Cards and tables aligned with design system; clear emphasis on decision and options
  - Visual diff/side-by-side comparison of options
- Accessibility:
  - Keyboard navigable, ARIA labels, sufficient color contrast
- State:
  - Reflects real-time approval status, with optimistic UI where appropriate

4) [page] Project Workspace Page
- Purpose: Project-level workspace showing comprehensive project context
- Features:
  - Lists: decisions, project files, team members, templates, and project overview (branding, settings)
  - Quick actions: create decision, invite teammate, apply template
  - Branding controls (logo, colors, typography) at project level
  - Export actions accessible per project with appropriate permissions
  - Filter/sort for decisions (status, date, owner)
- Data presentation:
  - Dashboard-like overview with cards, quick stats, and recent activity
  - Decision list with status chips and action menus
- Integration:
  - Links to Decision Detail per decision
  - Export history panel showing previous exports and statuses

5) [page] Operation Success Page / Modal
- Purpose: Generic success state shown after operations like share link creation, export generation, or payment completion
- Features:
  - Success message, summary of action taken
  - Actions: view export, download, share link, return to project/workspace
  - Optional: retry action or support contact info
- UX:
  - Consistent modal or full-page success pattern with clear next steps

---

## Implementation Requirements

### Frontend

- UI Components
  - DecisionDetailView: internal view with header, options grid, comparison panel, comments thread, approvals timeline, and admin action bar
  - ProjectWorkspace: project header with branding, actions, and a tabbed/kanban-like or grid-based workspace
  - ExportsPanel: export generation controls (select format, scope, branding), status indicators, and progress bars
  - SuccessModal/SuccessPage: reusable success state with customizable messaging and CTAs
  - FileAttachmentList: reference viewer with download/preview actions
  - StatusTag components: green/yellow/red status chips
  - JSON/CSV export download links
  - PDF render preview (optional) for user feedback before export
- Interactions
  - Trigger export workflow from DecisionDetail and ProjectWorkspace
  - Real-time progress indicators (polling or WebSocket) for export jobs
  - Retry/abort export with user confirmation
  - Accessibility: keyboard navigation, focus management, aria-live regions for status updates
- Design System Compliance
  - Use design tokens for colors, typography, spacing
  - Card, button, input, and table components consistent with the project style
- Data Handling
  - Local caching for export metadata; show export history per project/decision
  - Client-side validation for export options (format selection, scope)
- Internationalization
  - Prepare labels for i18n; default to English with placeholder for translations

### Backend

- Data Models
  - DecisionExport
    - id, decision_group_id or project_id, format (PDF/CSV/JSON), status (queued, processing, completed, failed), created_at, updated_at, artifact_url, size
    - request_payload (store options: which decisions, date ranges, branding)
    - backend_job_id, backend_status, progress
    - signatures_metadata (optional)
  - Decision
    - id, title, description, status, created_at, updated_at, author_id
  - Option
    - id, decision_id, text, rationale, order
  - Comment
    - id, decision_id, author_id, content, created_at, updated_at
  - Approval
    - id, decision_id, approver_id, status, timestamp, notes
  - Attachment
    - id, decision_id, file_id, reference_type, reference_id, url (s3), name, mime_type
  - ExportTemplate/BrandProfile
    - branding fields (logo_url, color tokens, typography settings)
  - User/Team
    - minimal for permissions and authorship
- APIs
  - POST /api/projects/{projectId}/exports
    - Body: { scope: "project" | "decision", decisionIds[], format: "PDF" | "CSV" | "JSON", brandingId?, includeSignatures?: boolean, resourceLinks?: boolean }
    - Response: { exportId, status: "queued" | "in_progress" | "completed" | "failed", progress?: 0-100, artifactUrl? }
  - GET /api/exports/{exportId}
    - Status, progress, artifactUrl, logs
  - GET /api/exports/{exportId}/download
    - Redirect or streaming download for artifact
  - POST /api/exports/{exportId}/retry
    - Retry a failed export
  - WebSocket / Polling or SSE endpoint to push progress updates (optional)
- PDF Generation Service
  - PDFGenerator interface with two implementations:
    - DocRaptorPDFGenerator
    - PuppeteerPDFGenerator
  - Methods: generateFromTemplate(templateHtml, dataModel, options) -> buffer or URL
  - Templating: HTML templates for header/footer, decision blocks, option comparisons, comments, approvals
  - Resource handling: fetch branding assets, attachments, and images securely
  - Output: PDF buffer, or file written to storage
- CSV/JSON Export Service
  - Flatten hierarchical decision data into normalized CSV rows
  - Field mappings:
    - decision_id, decision_title, decision_status, decision_created_at, decision_updated_at
    - option_id, option_text, option_rationale, option_order
    - comment_id, comment_author, comment_text, comment_created_at
    - approval_id, approver, approval_status, approval_timestamp
    - attachment_id, file_name, file_url
    - metadata fields: project_id, export_id, branding_version
  - JSON export mirrors the CSV schema with nested structures for options, comments, approvals
- Storage & Access
  - S3-compatible storage for export artifacts with pre-signed URLs for download
  - Access controls: only project members and authorized external clients with a share link can access exports
  - Expiration and lifecycle rules for old exports
- Queuing & Reliability
  - Preflight validation in a queue worker
  - Retries with exponential backoff for transient failures
  - Progress tracking and idempotent export generation
  - Observability: metrics for queue length, job duration, success/failure rates
- Security & Compliance
  - Authentication and authorization checks on all export endpoints
  - Data redaction policies if required by policy (configurable)
  - Optional digital signatures metadata for legal export packs
- Testing
  - Unit tests for data flattening/CSV/JSON mapping
  - Integration tests for PDF generation path (DocRaptor/Puppeteer)
  - End-to-end tests simulating export lifecycle

### Integration

- Frontend ↔ Backend
  - Trigger export from Decision Detail and Project Workspace actions
  - Display export progress and results in the UI
  - Provide download/preview links to artifacts
- PDF Generator ↔ Templating
  - Use branding profiles to render PDFs consistent with project branding
  - Support dynamic content sizing and charts (embed as images)
- Storage
  - Persist artifact URLs in DecisionExport and return to frontend
- Permissions
  - Enforce role-based access for project members; grant temporary access via signed URLs for external recipients

---

## User Experience Flow

1) User navigates to a Project Workspace
2) User selects one or more decisions or a decision group to export
3) User clicks Create Export (PDF/CSV/JSON) with options:
   - Scope: entire project decisions or selected decisions
   - Format: PDF (branded), CSV, or JSON
   - Branding: select brand profile (logo, colors, typography)
   - Include: attachments references, comments, approvals, digital signatures metadata
4) System validates request (permissions, data presence) and queues the export job
5) UI shows an Export card with status: Queued -> In Progress
6) Backend processes export via chosen PDF generator or CSV/JSON builder
7) On success: 
   - UI updates to Completed, artifact URL shown
   - User can download or share via a generated link
   - Optional success modal with summary and next steps
8) On failure:
   - UI shows Failed state with error details
   - User can Retry or view logs
9) If Export is large:
   - Show progress bar with percent complete
   - Allow cancellation if needed
10) Access control ensures only authorized users can view/download artifacts; external recipients use signed URLs with expiry

---

## Technical Specifications

### Data Models (Schema Overview)
- projects
  - id, name, branding_profile_id, settings
- decisions
  - id, project_id, title, description, status, created_at, updated_at, owner_id
- options
  - id, decision_id, text, rationale, order
- comments
  - id, decision_id, author_id, content, created_at, updated_at
- approvals
  - id, decision_id, approver_id, status, timestamp, notes
- attachments
  - id, decision_id, file_id, reference_type, reference_id, url, name, mime_type
- exports
  - id, project_id, scope, format, status, created_at, updated_at, artifact_url, progress, request_payload JSON, branding_profile_id
- branding_profiles
  - id, name, logo_url, primary_color, accent_color, typography_settings
- users
  - id, name, email, role, permissions
- export_logs
  - id, export_id, message, level, timestamp

### API Endpoints
- POST /api/projects/{projectId}/exports
  - Body: { scope: "project"|"decision", decisionIds: [ids], format: "PDF"|"CSV"|"JSON", brandingProfileId?, includeSignatures?: boolean, includeAttachments?: boolean }
  - Response: { exportId, status, progress }
- GET /api/exports/{exportId}
  - Response: { exportId, status, progress, artifactUrl, logs }
- GET /api/exports/{exportId}/download
  - Response: file download or signed URL
- POST /api/exports/{exportId}/retry
  - Response: updated status
- WebSocket/SSE: /ws/exports
  - Real-time progress events: { exportId, status, progress, message }

### Security
- Authentication: OAuth2 / JWT-based per project
- Authorization: role-based checks (viewer, editor, admin)
- Data access: only members of the project or explicitly shared recipients
- Sanitize and validate all inputs
- Export artifacts: stored privately in S3 with signed URL access control; optional expiring links

### Validation
- Validate required fields: projectId, decisionIds or scope
- Validate brandingProfileId if provided
- Ensure requested decisions belong to the project
- Quota checks (export size, rate limits) if necessary

---

## Acceptance Criteria

- [ ] PDF export renders branded document with header/footer, decision sections, options, comments, approvals, and attachment references; includes optional digital signature block; uses DocRaptor or Puppeteer backend with proper templating
- [ ] CSV export flattens decisions with options, comments, approvals, and attachments; field mapping consistent; downloadable via API
- [ ] JSON export provides a structured representation mirroring the CSV/Flat fields with nested arrays for options, comments, approvals, and attachments
- [ ] API endpoints support creation, status polling, and secure download; export artifacts stored in S3 with signed URL access
- [ ] Preflight export job: validation, queuing, retry logic, progress reporting; errors surface with actionable messages
- [ ] Internal Decision Detail page supports viewing, editing, commenting, approving, and exporting; export triggers show progress and results
- [ ] Project Workspace page lists decisions, files, team, templates, and branding; exports are accessible with proper permissions
- [ ] Operation Success page/modal provides clear success state with next steps and downloadable artifact
- [ ] UI adheres to Design System: cards, typography, spacing, color tokens, responsive behavior, and accessible contrast

---

## UI/UX Guidelines

- Align with Archject visual system:
  - Cards with white backgrounds, soft shadows, rounded corners
  - Top navigation with pill-shaped tabs; active state in deep green (#195C4A)
  - Left-aligned content with strong vertical rhythm; generous padding (24-32px)
  - 8px spacing increments; consistent typography weights (400/500/600)
  - Status tags in green/yellow/red with bold text
- Data visualization remains consistent: charts use accent colors, minimal grid, clean typography
- Interactive elements:
  - Pill-shaped buttons; primary actions in deep green; hover states with subtle elevation
  - Soft inputs with light background (#F5F6FA) and clear focus rings
  - Smooth micro-interactions for hover, focus, and state changes
- Mobile-first approach with responsive layout grids and large tap targets

---

## Visual Style

- Color Palette (as provided):
  - Primary: #FFFFFF
  - Secondary: #F5F6FA, #F7F8FA
  - Accent:
    - Deep green: #195C4A
    - Bright green: #7BE495
    - Soft yellow: #FFE8A3
    - Muted orange: #FFDCA8
    - Light red: #FF6C6C
  - Text:
    - Dark gray: #23272F
    - Medium gray: #6B7280
  - Subtle shadows/borders: #E6E8F0, #D1D5DB
- Typography:
  - Font family: Inter / SF Pro / Manrope
  - Weights: 400, 500, 600
- Layout and components should preserve strong visual hierarchy, readability, and whitespace

---

## Development Prompts for AI Tool (Actionable Prompts)

- Create data models for DecisionExport, with fields to capture scope, format, branding, status, progress, artifact_url, and request_payload; ensure relations to project/decisions and branding profiles.
- Implement a PDF generation service interface with two backends (DocRaptorPDFGenerator and PuppeteerPDFGenerator). Provide a single method generateFromTemplate(templateHtml, dataModel, options) and a factory to choose backend based on config. Include header/footer templating hooks and branding support.
- Build an HTML/CSS template for PDF rendering that accepts data_model (decisions, options, comments, approvals, attachments). Include placeholders for branding header/footer and a digital-signature block if enabled.
- Implement CSV/JSON export builders:
  - CSV: flatten decisions into rows with joined fields for options, comments, approvals; provide header row and sample data. Ensure proper escaping for commas and quotes.
  - JSON: produce a structured object with decisions[]; each decision contains options[], comments[], approvals[], attachments[]. Include metadata fields.
- Create an asynchronous export pipeline:
  - Validate input; enqueue a job with export_request
  - Worker consumes job; fetches decisions, builds data payload; calls PDF/CSV/JSON builders; uploads artifact to S3; updates export status and artifact_url
  - Implement retry policy with exponential backoff and a max retry cap
  - Emit progress events (0-100%) via WebSocket or SSE to frontend
- Implement API endpoints:
  - POST /api/projects/{projectId}/exports
    - Validate: project exists, user authorization, decisionIds subset, format supported
    - Create DecisionExport record; enqueue job; respond with exportId and initial status
  - GET /api/exports/{exportId}
    - Return status, progress, artifact_url (if available), logs
  - GET /api/exports/{exportId}/download
    - Serve or redirect to signed S3 URL; ensure authorization
  - POST /api/exports/{exportId}/retry
    - Trigger retry workflow
- Implement security:
  - JWT/OAuth2 authenticated routes
  - Role-based access: only project members can create/monitor exports; external recipients via signed URLs for downloads
  - Validate and sanitize all inputs; ensure no private data leakage
- Frontend Components:
  - DecisionDetailView:
    - Render decision and options; show comments/annotations; approvals history; admin actions (edit, revoke, export)
    - Provide Export button with options and branding picker; show progress status
  - ProjectWorkspace:
    - Card-based grid/list of decisions; branding and project overview; export trigger from workspace
  - ExportsPanel:
    - UI for selecting scope, format, branding; shows export history with progress bars and status
  - SuccessModal/SuccessPage:
    - Generic success state with action CTAs (download, view export, return to workspace)
- Integration:
  - Wire export triggers from UI to backend, handle asynchronous feedback, and display artifact URLs securely
  - Ensure branding/profile data is properly consumed by the PDF generator
  - Wire up S3 URLs with short-lived signed links for downloads
- Tests:
  - Unit tests for data mapping and CSV/JSON generation
  - Integration tests for export lifecycle (creation, processing, success/failure)
  - E2E tests simulating UI flow: trigger export, monitor progress, download artifact
  - Security tests for authorization on export endpoints

---

## Deliverables

- Full data models and database migrations for DecisionExport and related entities
- Backend services:
  - PDFGenerator interface and two backends (DocRaptor/Puppeteer) with templating hooks
  - CSV/JSON export builders
  - Export pipeline with queuing, retries, and progress reporting
  - S3 integration and signed URL utilities
- API specification documentation (OpenAPI-like or Swagger) for export endpoints
- Frontend components and screens as described, wired to backend endpoints
- Design references:
  - UI components, tokens, and templates aligned with the Archject design system
  - PDF header/footer templates and branding assets
- Tests: unit/integration/e2e tests as described
- Deployment notes and rollback plan for enabling the export feature in staging/production

---

If you need, I can tailor this prompt further to your preferred tech stack (e.g., Node.js with NestJS or Python with FastAPI, React or Vue frontend, PostgreSQL), or provide concrete template files (schema SQL, API specs, HTML templates, and sample data). for style.

CRITICAL DESIGN REQUIREMENTS:
- You MUST follow ALL design principles and patterns specified in the Design Reference above
- Do NOT deviate from the design specifications without explicit user permission
- Implement ALL visual design elements (colors, typography, spacing, shadows, animations) as specified
- Follow the layout patterns and component designs exactly as documented
- Ensure all interactions and micro-animations match the reference specifications

CRITICAL TECHNICAL REQUIREMENTS:
- React 18.3.1, React Router 6.30.1
- Tailwind CSS v3 with tailwind.config.js and custom keyframes
- @tailwindcss/typography plugin for rich text content
- Tailwind CSS animations (NOT Motion library or framer-motion)
- Sonner for toasts
- Recharts for data visualization
- Native fetch() with API utilities in src/lib/api.ts
- Design system with CSS custom properties
- Use RGB color values for theming
- When Supabase is configured: use Edge Functions for LLM and server-only logic; never expose API keys in the client

=== TASK ===
# Decision Log Exports (PDF/CSV)

## Overview
Build a comprehensive Decision Log Exports feature set for Archject that enables exporting structured, branded decision logs. Exports must support:
- Human-readable, branded PDFs generated server-side via DocRaptor or Puppeteer
- Machine-readable CSV and JSON exports
- Attachments references and related metadata (decisions, options, comments, approvals, and file references)
- Preflight/export job queue with progress tracking and retry handling
- Access-controlled storage of export artifacts in S3
- Optional inclusion of digital-signature metadata for legal/export packs
- Integration with internal pages: Decision Detail (Internal), Project Workspace Page, and a generic Operation Success Page/Modal

This prompt is intended for an AI development tool to generate, scaffold, and implement the feature end-to-end with concrete artifacts (data models, APIs, UI components, workflows, tests, and integration details) aligned to the Archject design system and project context.

---

## Components to Build

1) [feature] Decision Log Exports (PDF/CSV)
- Purpose: Produce export artifacts for decisions and their context, consumable by clients and auditors.
- Outputs:
  - PDF: Branded, print-ready document with header/footer, page numbers, and optional digital-signature block.
  - CSV: Flat, machine-readable rows with normalized fields for programmatic consumption.
  - JSON: Structured export payload for API consumers or downstream systems.
- Contents:
  - Decision data: id, title, description, status, timestamps
  - Options: option_id, text, rationale, decision outcome per option
  - Comments/annotations: user, timestamp, content, mentions
  - Approvals: approver, role, status, timestamp, notes
  - Attached files references: file_id, file_name, type, URL/unsigned S3 key, references to related decisions/options
  - Metadata: project_id, decision_group, branding/version, export_timestamp, export_version
  - Optional: digital signatures metadata (signatory, certificate, timestamp, hash)
  - Audit trail entries (optional per design): action, actor, timestamp
- Performance/scale:
  - Support small (10-50 decisions) to large (1000+ decisions) export packs
  - Streaming/chunked generation for large PDFs
- Accessibility and localization: support en-US by default, ready for i18n

2) [api] DocRaptor / Puppeteer (PDF Generation)
- Purpose: Server-side rendering of branded PDFs from HTML templates or render engine output.
- Features:
  - Templating hooks for header/footer with branding ( logo, client name, project, page numbers, date)
  - Styles compatible with CSS-in-JS or external stylesheets
  - Control over page size, margins, orientation
  - Support for images/attachments, embedded charts (rendered as images)
  - Options for digital signature block and legal disclaimers
  - Retry logic and queue integration for reliability
  - Separate endpoints for initiating export, status checks, and retrieving artifact URL
- Implementation choices:
  - Prefer DocRaptor for simpler API or Puppeteer for full control; abstract behind a PDFGenerator service with pluggable backends
- Security:
  - Ensure PDFs are generated in a secure, isolated environment; enforce access controls to export artifacts

3) [page] Decision Detail (Internal)
- Purpose: Rich, internal view to review a decision and its lifecycle
- Features:
  - Display decision with all options side-by-side (comparison)
  - Show comments/annotations with threaded replies and @mentions
  - Show approval history (who approved when, status)
  - Admin actions: edit decision, revoke approval, export (PDF/CSV/JSON), add comment
  - Download/export triggers (asynchronous) with progress indicators
  - Inline editing for decision fields (title, description) with autosave or explicit save
  - Attachments panel with file references and actions (view, download)
  - Keyboard shortcuts for power users
- Data presentation:
  - Cards and tables aligned with design system; clear emphasis on decision and options
  - Visual diff/side-by-side comparison of options
- Accessibility:
  - Keyboard navigable, ARIA labels, sufficient color contrast
- State:
  - Reflects real-time approval status, with optimistic UI where appropriate

4) [page] Project Workspace Page
- Purpose: Project-level workspace showing comprehensive project context
- Features:
  - Lists: decisions, project files, team members, templates, and project overview (branding, settings)
  - Quick actions: create decision, invite teammate, apply template
  - Branding controls (logo, colors, typography) at project level
  - Export actions accessible per project with appropriate permissions
  - Filter/sort for decisions (status, date, owner)
- Data presentation:
  - Dashboard-like overview with cards, quick stats, and recent activity
  - Decision list with status chips and action menus
- Integration:
  - Links to Decision Detail per decision
  - Export history panel showing previous exports and statuses

5) [page] Operation Success Page / Modal
- Purpose: Generic success state shown after operations like share link creation, export generation, or payment completion
- Features:
  - Success message, summary of action taken
  - Actions: view export, download, share link, return to project/workspace
  - Optional: retry action or support contact info
- UX:
  - Consistent modal or full-page success pattern with clear next steps

---

## Implementation Requirements

### Frontend

- UI Components
  - DecisionDetailView: internal view with header, options grid, comparison panel, comments thread, approvals timeline, and admin action bar
  - ProjectWorkspace: project header with branding, actions, and a tabbed/kanban-like or grid-based workspace
  - ExportsPanel: export generation controls (select format, scope, branding), status indicators, and progress bars
  - SuccessModal/SuccessPage: reusable success state with customizable messaging and CTAs
  - FileAttachmentList: reference viewer with download/preview actions
  - StatusTag components: green/yellow/red status chips
  - JSON/CSV export download links
  - PDF render preview (optional) for user feedback before export
- Interactions
  - Trigger export workflow from DecisionDetail and ProjectWorkspace
  - Real-time progress indicators (polling or WebSocket) for export jobs
  - Retry/abort export with user confirmation
  - Accessibility: keyboard navigation, focus management, aria-live regions for status updates
- Design System Compliance
  - Use design tokens for colors, typography, spacing
  - Card, button, input, and table components consistent with the project style
- Data Handling
  - Local caching for export metadata; show export history per project/decision
  - Client-side validation for export options (format selection, scope)
- Internationalization
  - Prepare labels for i18n; default to English with placeholder for translations

### Backend

- Data Models
  - DecisionExport
    - id, decision_group_id or project_id, format (PDF/CSV/JSON), status (queued, processing, completed, failed), created_at, updated_at, artifact_url, size
    - request_payload (store options: which decisions, date ranges, branding)
    - backend_job_id, backend_status, progress
    - signatures_metadata (optional)
  - Decision
    - id, title, description, status, created_at, updated_at, author_id
  - Option
    - id, decision_id, text, rationale, order
  - Comment
    - id, decision_id, author_id, content, created_at, updated_at
  - Approval
    - id, decision_id, approver_id, status, timestamp, notes
  - Attachment
    - id, decision_id, file_id, reference_type, reference_id, url (s3), name, mime_type
  - ExportTemplate/BrandProfile
    - branding fields (logo_url, color tokens, typography settings)
  - User/Team
    - minimal for permissions and authorship
- APIs
  - POST /api/projects/{projectId}/exports
    - Body: { scope: "project" | "decision", decisionIds[], format: "PDF" | "CSV" | "JSON", brandingId?, includeSignatures?: boolean, resourceLinks?: boolean }
    - Response: { exportId, status: "queued" | "in_progress" | "completed" | "failed", progress?: 0-100, artifactUrl? }
  - GET /api/exports/{exportId}
    - Status, progress, artifactUrl, logs
  - GET /api/exports/{exportId}/download
    - Redirect or streaming download for artifact
  - POST /api/exports/{exportId}/retry
    - Retry a failed export
  - WebSocket / Polling or SSE endpoint to push progress updates (optional)
- PDF Generation Service
  - PDFGenerator interface with two implementations:
    - DocRaptorPDFGenerator
    - PuppeteerPDFGenerator
  - Methods: generateFromTemplate(templateHtml, dataModel, options) -> buffer or URL
  - Templating: HTML templates for header/footer, decision blocks, option comparisons, comments, approvals
  - Resource handling: fetch branding assets, attachments, and images securely
  - Output: PDF buffer, or file written to storage
- CSV/JSON Export Service
  - Flatten hierarchical decision data into normalized CSV rows
  - Field mappings:
    - decision_id, decision_title, decision_status, decision_created_at, decision_updated_at
    - option_id, option_text, option_rationale, option_order
    - comment_id, comment_author, comment_text, comment_created_at
    - approval_id, approver, approval_status, approval_timestamp
    - attachment_id, file_name, file_url
    - metadata fields: project_id, export_id, branding_version
  - JSON export mirrors the CSV schema with nested structures for options, comments, approvals
- Storage & Access
  - S3-compatible storage for export artifacts with pre-signed URLs for download
  - Access controls: only project members and authorized external clients with a share link can access exports
  - Expiration and lifecycle rules for old exports
- Queuing & Reliability
  - Preflight validation in a queue worker
  - Retries with exponential backoff for transient failures
  - Progress tracking and idempotent export generation
  - Observability: metrics for queue length, job duration, success/failure rates
- Security & Compliance
  - Authentication and authorization checks on all export endpoints
  - Data redaction policies if required by policy (configurable)
  - Optional digital signatures metadata for legal export packs
- Testing
  - Unit tests for data flattening/CSV/JSON mapping
  - Integration tests for PDF generation path (DocRaptor/Puppeteer)
  - End-to-end tests simulating export lifecycle

### Integration

- Frontend ↔ Backend
  - Trigger export from Decision Detail and Project Workspace actions
  - Display export progress and results in the UI
  - Provide download/preview links to artifacts
- PDF Generator ↔ Templating
  - Use branding profiles to render PDFs consistent with project branding
  - Support dynamic content sizing and charts (embed as images)
- Storage
  - Persist artifact URLs in DecisionExport and return to frontend
- Permissions
  - Enforce role-based access for project members; grant temporary access via signed URLs for external recipients

---

## User Experience Flow

1) User navigates to a Project Workspace
2) User selects one or more decisions or a decision group to export
3) User clicks Create Export (PDF/CSV/JSON) with options:
   - Scope: entire project decisions or selected decisions
   - Format: PDF (branded), CSV, or JSON
   - Branding: select brand profile (logo, colors, typography)
   - Include: attachments references, comments, approvals, digital signatures metadata
4) System validates request (permissions, data presence) and queues the export job
5) UI shows an Export card with status: Queued -> In Progress
6) Backend processes export via chosen PDF generator or CSV/JSON builder
7) On success: 
   - UI updates to Completed, artifact URL shown
   - User can download or share via a generated link
   - Optional success modal with summary and next steps
8) On failure:
   - UI shows Failed state with error details
   - User can Retry or view logs
9) If Export is large:
   - Show progress bar with percent complete
   - Allow cancellation if needed
10) Access control ensures only authorized users can view/download artifacts; external recipients use signed URLs with expiry

---

## Technical Specifications

### Data Models (Schema Overview)
- projects
  - id, name, branding_profile_id, settings
- decisions
  - id, project_id, title, description, status, created_at, updated_at, owner_id
- options
  - id, decision_id, text, rationale, order
- comments
  - id, decision_id, author_id, content, created_at, updated_at
- approvals
  - id, decision_id, approver_id, status, timestamp, notes
- attachments
  - id, decision_id, file_id, reference_type, reference_id, url, name, mime_type
- exports
  - id, project_id, scope, format, status, created_at, updated_at, artifact_url, progress, request_payload JSON, branding_profile_id
- branding_profiles
  - id, name, logo_url, primary_color, accent_color, typography_settings
- users
  - id, name, email, role, permissions
- export_logs
  - id, export_id, message, level, timestamp

### API Endpoints
- POST /api/projects/{projectId}/exports
  - Body: { scope: "project"|"decision", decisionIds: [ids], format: "PDF"|"CSV"|"JSON", brandingProfileId?, includeSignatures?: boolean, includeAttachments?: boolean }
  - Response: { exportId, status, progress }
- GET /api/exports/{exportId}
  - Response: { exportId, status, progress, artifactUrl, logs }
- GET /api/exports/{exportId}/download
  - Response: file download or signed URL
- POST /api/exports/{exportId}/retry
  - Response: updated status
- WebSocket/SSE: /ws/exports
  - Real-time progress events: { exportId, status, progress, message }

### Security
- Authentication: OAuth2 / JWT-based per project
- Authorization: role-based checks (viewer, editor, admin)
- Data access: only members of the project or explicitly shared recipients
- Sanitize and validate all inputs
- Export artifacts: stored privately in S3 with signed URL access control; optional expiring links

### Validation
- Validate required fields: projectId, decisionIds or scope
- Validate brandingProfileId if provided
- Ensure requested decisions belong to the project
- Quota checks (export size, rate limits) if necessary

---

## Acceptance Criteria

- [ ] PDF export renders branded document with header/footer, decision sections, options, comments, approvals, and attachment references; includes optional digital signature block; uses DocRaptor or Puppeteer backend with proper templating
- [ ] CSV export flattens decisions with options, comments, approvals, and attachments; field mapping consistent; downloadable via API
- [ ] JSON export provides a structured representation mirroring the CSV/Flat fields with nested arrays for options, comments, approvals, and attachments
- [ ] API endpoints support creation, status polling, and secure download; export artifacts stored in S3 with signed URL access
- [ ] Preflight export job: validation, queuing, retry logic, progress reporting; errors surface with actionable messages
- [ ] Internal Decision Detail page supports viewing, editing, commenting, approving, and exporting; export triggers show progress and results
- [ ] Project Workspace page lists decisions, files, team, templates, and branding; exports are accessible with proper permissions
- [ ] Operation Success page/modal provides clear success state with next steps and downloadable artifact
- [ ] UI adheres to Design System: cards, typography, spacing, color tokens, responsive behavior, and accessible contrast

---

## UI/UX Guidelines

- Align with Archject visual system:
  - Cards with white backgrounds, soft shadows, rounded corners
  - Top navigation with pill-shaped tabs; active state in deep green (#195C4A)
  - Left-aligned content with strong vertical rhythm; generous padding (24-32px)
  - 8px spacing increments; consistent typography weights (400/500/600)
  - Status tags in green/yellow/red with bold text
- Data visualization remains consistent: charts use accent colors, minimal grid, clean typography
- Interactive elements:
  - Pill-shaped buttons; primary actions in deep green; hover states with subtle elevation
  - Soft inputs with light background (#F5F6FA) and clear focus rings
  - Smooth micro-interactions for hover, focus, and state changes
- Mobile-first approach with responsive layout grids and large tap targets

---

## Visual Style

- Color Palette (as provided):
  - Primary: #FFFFFF
  - Secondary: #F5F6FA, #F7F8FA
  - Accent:
    - Deep green: #195C4A
    - Bright green: #7BE495
    - Soft yellow: #FFE8A3
    - Muted orange: #FFDCA8
    - Light red: #FF6C6C
  - Text:
    - Dark gray: #23272F
    - Medium gray: #6B7280
  - Subtle shadows/borders: #E6E8F0, #D1D5DB
- Typography:
  - Font family: Inter / SF Pro / Manrope
  - Weights: 400, 500, 600
- Layout and components should preserve strong visual hierarchy, readability, and whitespace

---

## Development Prompts for AI Tool (Actionable Prompts)

- Create data models for DecisionExport, with fields to capture scope, format, branding, status, progress, artifact_url, and request_payload; ensure relations to project/decisions and branding profiles.
- Implement a PDF generation service interface with two backends (DocRaptorPDFGenerator and PuppeteerPDFGenerator). Provide a single method generateFromTemplate(templateHtml, dataModel, options) and a factory to choose backend based on config. Include header/footer templating hooks and branding support.
- Build an HTML/CSS template for PDF rendering that accepts data_model (decisions, options, comments, approvals, attachments). Include placeholders for branding header/footer and a digital-signature block if enabled.
- Implement CSV/JSON export builders:
  - CSV: flatten decisions into rows with joined fields for options, comments, approvals; provide header row and sample data. Ensure proper escaping for commas and quotes.
  - JSON: produce a structured object with decisions[]; each decision contains options[], comments[], approvals[], attachments[]. Include metadata fields.
- Create an asynchronous export pipeline:
  - Validate input; enqueue a job with export_request
  - Worker consumes job; fetches decisions, builds data payload; calls PDF/CSV/JSON builders; uploads artifact to S3; updates export status and artifact_url
  - Implement retry policy with exponential backoff and a max retry cap
  - Emit progress events (0-100%) via WebSocket or SSE to frontend
- Implement API endpoints:
  - POST /api/projects/{projectId}/exports
    - Validate: project exists, user authorization, decisionIds subset, format supported
    - Create DecisionExport record; enqueue job; respond with exportId and initial status
  - GET /api/exports/{exportId}
    - Return status, progress, artifact_url (if available), logs
  - GET /api/exports/{exportId}/download
    - Serve or redirect to signed S3 URL; ensure authorization
  - POST /api/exports/{exportId}/retry
    - Trigger retry workflow
- Implement security:
  - JWT/OAuth2 authenticated routes
  - Role-based access: only project members can create/monitor exports; external recipients via signed URLs for downloads
  - Validate and sanitize all inputs; ensure no private data leakage
- Frontend Components:
  - DecisionDetailView:
    - Render decision and options; show comments/annotations; approvals history; admin actions (edit, revoke, export)
    - Provide Export button with options and branding picker; show progress status
  - ProjectWorkspace:
    - Card-based grid/list of decisions; branding and project overview; export trigger from workspace
  - ExportsPanel:
    - UI for selecting scope, format, branding; shows export history with progress bars and status
  - SuccessModal/SuccessPage:
    - Generic success state with action CTAs (download, view export, return to workspace)
- Integration:
  - Wire export triggers from UI to backend, handle asynchronous feedback, and display artifact URLs securely
  - Ensure branding/profile data is properly consumed by the PDF generator
  - Wire up S3 URLs with short-lived signed links for downloads
- Tests:
  - Unit tests for data mapping and CSV/JSON generation
  - Integration tests for export lifecycle (creation, processing, success/failure)
  - E2E tests simulating UI flow: trigger export, monitor progress, download artifact
  - Security tests for authorization on export endpoints

---

## Deliverables

- Full data models and database migrations for DecisionExport and related entities
- Backend services:
  - PDFGenerator interface and two backends (DocRaptor/Puppeteer) with templating hooks
  - CSV/JSON export builders
  - Export pipeline with queuing, retries, and progress reporting
  - S3 integration and signed URL utilities
- API specification documentation (OpenAPI-like or Swagger) for export endpoints
- Frontend components and screens as described, wired to backend endpoints
- Design references:
  - UI components, tokens, and templates aligned with the Archject design system
  - PDF header/footer templates and branding assets
- Tests: unit/integration/e2e tests as described
- Deployment notes and rollback plan for enabling the export feature in staging/production

---

If you need, I can tailor this prompt further to your preferred tech stack (e.g., Node.js with NestJS or Python with FastAPI, React or Vue frontend, PostgreSQL), or provide concrete template files (schema SQL, API specs, HTML templates, and sample data).

=== SUCCESS CRITERIA ===
# Success Criteria Checklist

## Code Quality

### TypeScript
- [ ] No TypeScript errors (`tsc --noEmit` passes)
- [ ] All functions and components have proper type definitions
- [ ] No `any` types used (use `unknown` if type is truly unknown)
- [ ] Props interfaces defined for all components
- [ ] API responses have type definitions

### Code Standards
- [ ] All imports use path aliases (@/ prefix)
- [ ] Components follow the established naming convention
- [ ] Files are organized in correct directories
- [ ] No unused imports or variables
- [ ] Consistent code formatting

## Component Implementation

### UI Components
- [ ] Use shadcn/ui components (Button, Card, Input, etc.) instead of building from scratch
- [ ] All interactive elements have hover states
- [ ] Components use the `cn()` utility for class merging
- [ ] Proper TypeScript props interfaces defined
- [ ] Components are responsive (mobile, tablet, desktop)

### Animations
- [ ] Motion library used for all animations (NOT framer-motion)
- [ ] Page transitions implemented with fade/slide
- [ ] Interactive elements have whileHover/whileTap animations
- [ ] List items use stagger animations where appropriate
- [ ] Animations respect `prefers-reduced-motion`

### Icons
- [ ] Lucide React icons used consistently
- [ ] Icons have consistent sizing (h-4 w-4, h-5 w-5, h-6 w-6)
- [ ] Icon colors match design system (text-primary, text-muted-foreground)

## Data Management

### React Query
- [ ] All data fetching uses React Query hooks
- [ ] Query keys follow the established pattern
- [ ] Mutations invalidate related queries
- [ ] Loading and error states handled
- [ ] Optimistic updates implemented where appropriate

### Forms
- [ ] Forms use react-hook-form
- [ ] Validation uses Zod schemas
- [ ] Error messages display properly
- [ ] Form submission shows loading state
- [ ] Success/error feedback via toast notifications

### API Layer
- [ ] API functions in src/api/ directory
- [ ] Axios used for HTTP requests
- [ ] Proper error handling with try/catch
- [ ] Auth tokens handled by interceptors
- [ ] Type-safe API function signatures

## User Experience

### Notifications
- [ ] Sonner toasts used for all notifications
- [ ] Success actions show success toast
- [ ] Errors show descriptive error messages
- [ ] Loading states show toast.loading()

### Loading States
- [ ] Skeleton loaders shown during data fetch
- [ ] Buttons show loading state during submission
- [ ] Disabled state applied during async operations

### Error Handling
- [ ] Network errors caught and displayed
- [ ] User-friendly error messages (no stack traces)
- [ ] Fallback UI for error states
- [ ] No unhandled promise rejections

## Navigation

### Route Accessibility
- [ ] All pages have routes defined in router configuration
- [ ] Every page is accessible through navigation (menu, sidebar, or direct URL)
- [ ] Main pages (Dashboard, Home, Settings, etc.) accessible from primary navigation
- [ ] Secondary pages accessible through contextual navigation or direct links
- [ ] Deep-linked pages have breadcrumbs or back navigation
- [ ] 404/Not Found page implemented for invalid routes
- [ ] Protected routes have proper authentication checks
- [ ] Navigation state persists across page refreshes where appropriate

### Navigation UX
- [ ] Active route highlighted in navigation menu
- [ ] Clear visual hierarchy in navigation structure
- [ ] Mobile navigation is accessible and usable
- [ ] Navigation items have hover/focus states
- [ ] Nested routes show parent-child relationships
- [ ] User can always return to main areas (Dashboard/Home)

## Styling

### Tailwind CSS
- [ ] Tailwind v3 classes used
- [ ] HSL color variables from design system
- [ ] Custom CSS properties used where defined
- [ ] Responsive breakpoints: mobile-first approach
- [ ] Dark mode support via CSS variables

### Design System
- [ ] Colors use theme variables (primary, secondary, accent)
- [ ] Spacing uses Tailwind scale (p-4, gap-6, etc.)
- [ ] Border radius uses theme values (rounded-lg)
- [ ] Shadows use theme values (shadow-card)
- [ ] Typography follows Inter font system

## Accessibility

- [ ] Semantic HTML elements used
- [ ] Buttons have descriptive labels
- [ ] Forms have proper labels
- [ ] Focus states visible on interactive elements
- [ ] Color contrast meets WCAG standards

## Performance

- [ ] No console.log statements in production code
- [ ] No console errors in browser
- [ ] Images optimized (WebP, lazy loading)
- [ ] Large lists use virtualization if needed
- [ ] React Query cache configured appropriately

## Testing Readiness

- [ ] Components structured for easy testing
- [ ] Business logic separated from presentation
- [ ] Mock-friendly API layer
- [ ] No hardcoded values that should be configurable
- [ ] Environment variables properly configured

## Final Checks

- [ ] Code builds without errors (`npm run build`)
- [ ] Development server runs without errors (`npm run dev`)
- [ ] No TypeScript errors in editor
- [ ] Browser console is clean (no errors or warnings)
- [ ] All functionality works as expected
- [ ] Code follows existing project patterns
- [ ] Changes are consistent with the rest of the codebase



IMPORTANT: ALL styling and design decisions must follow the Design Reference section above EXACTLY. Do not make arbitrary design choices.

Analyze the existing project structure and implement the task following the patterns already established. Ensure all success criteria are met.