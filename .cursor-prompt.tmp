⚠️ CRITICAL EXECUTION RULES - READ FIRST ⚠️
❌ NEVER run: npm run dev, npm start, yarn dev, pnpm dev, or ANY development server
❌ NEVER run: long-running processes, servers, or commands that don't exit
❌ NEVER test the application by starting it
✅ ALLOWED: npm install, npm run build, npm run test (if needed)
✅ YOUR TASK: Create/modify files only, then STOP and EXIT immediately
⚠️ The MCP server handles all testing and validation separately

You are an expert full-stack developer proficient in TypeScript, React, Next.js, and modern UI/UX frameworks (Tailwind CSS, Shadcn UI, Radix UI).

=== DESIGN REFERENCE (MANDATORY) ===
# Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions


---

# Project-Specific Customizations

**IMPORTANT: This section contains the specific design requirements for THIS project. The guidelines above are universal best practices - these customizations below take precedence for project-specific decisions.**

## User Design Requirements

- Ensure all skeletons use the same color families and shimmer treatment as other components.
- Maintain glassy, calm aesthetics with soft shadows, rounded corners, and ample white space.
- Use the accent colors for progress/status cues only when appropriate within skeletons (e.g., a fake progress bar color might reflect the in-progress yellow/orange palette).
- Keep interactions subtle; avoid distracting animations beyond the shimmer.

---

## Visual Style (Recap)

Color Palette:
- Primary: #FFFFFF
- Secondary: #F5F6FA, #F7F8FA
- Accent: #195C4A (deep green), #7BE495 (bright green), #FFE8A3 (soft yellow), #FFDCA8 (muted orange), #FF6C6C (light red)
- Text: #23272F (dark gray), #6B7280 (medium gray)
- Subtle shadows/borders: #E6E8F0, #D1D5DB

Typography & Layout:
- Font: Inter / SF Pro / Manrope family
- Weights: 400, 500, 600
- Layout: 24-32px container padding, 16-24px gaps, 8px increments
- Card Design: White background, shadows, 12-16px radius, generous internal padding (≥24px)

Key Design Elements:
- Card, Navigation, Data Visualization, Interactive Elements, Micro-interactions
- Focus on clarity, accessibility, mobile-first, and trust-building visuals

---

Generate the complete, detailed prompt now:
- Provide structured sections as above.
- Include explicit prop definitions, example usage snippets, and recommended test cases.
- Include implementation notes that a developer can directly translate into code or a tool-driven build.

## Implementation Notes

When implementing this project:

1. **Follow Universal Guidelines**: Use the design best practices documented above as your foundation
2. **Apply Project Customizations**: Implement the specific design requirements stated in the "User Design Requirements" section
3. **Priority Order**: Project-specific requirements override universal guidelines when there's a conflict
4. **Color System**: Extract and implement color values as CSS custom properties in RGB format
5. **Typography**: Define font families, sizes, and weights based on specifications
6. **Spacing**: Establish consistent spacing scale following the design system
7. **Components**: Style all Shadcn components to match the design aesthetic
8. **Animations**: Use Motion library for transitions matching the design personality
9. **Responsive Design**: Ensure mobile-first responsive implementation

## Implementation Checklist

- [ ] Review universal design guidelines above
- [ ] Extract project-specific color palette and define CSS variables
- [ ] Configure Tailwind theme with custom colors
- [ ] Set up typography system (fonts, sizes, weights)
- [ ] Define spacing and sizing scales
- [ ] Create component variants matching design
- [ ] Implement responsive breakpoints
- [ ] Add animations and transitions
- [ ] Ensure accessibility standards
- [ ] Validate against user design requirements

---

**Remember: Always reference this file for design decisions. Do not use generic or placeholder designs.**


*IMPORTANT*: For every page or component refer to # Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions


---

# Project-Specific Customizations

**IMPORTANT: This section contains the specific design requirements for THIS project. The guidelines above are universal best practices - these customizations below take precedence for project-specific decisions.**

## User Design Requirements

- Ensure all skeletons use the same color families and shimmer treatment as other components.
- Maintain glassy, calm aesthetics with soft shadows, rounded corners, and ample white space.
- Use the accent colors for progress/status cues only when appropriate within skeletons (e.g., a fake progress bar color might reflect the in-progress yellow/orange palette).
- Keep interactions subtle; avoid distracting animations beyond the shimmer.

---

## Visual Style (Recap)

Color Palette:
- Primary: #FFFFFF
- Secondary: #F5F6FA, #F7F8FA
- Accent: #195C4A (deep green), #7BE495 (bright green), #FFE8A3 (soft yellow), #FFDCA8 (muted orange), #FF6C6C (light red)
- Text: #23272F (dark gray), #6B7280 (medium gray)
- Subtle shadows/borders: #E6E8F0, #D1D5DB

Typography & Layout:
- Font: Inter / SF Pro / Manrope family
- Weights: 400, 500, 600
- Layout: 24-32px container padding, 16-24px gaps, 8px increments
- Card Design: White background, shadows, 12-16px radius, generous internal padding (≥24px)

Key Design Elements:
- Card, Navigation, Data Visualization, Interactive Elements, Micro-interactions
- Focus on clarity, accessibility, mobile-first, and trust-building visuals

---

Generate the complete, detailed prompt now:
- Provide structured sections as above.
- Include explicit prop definitions, example usage snippets, and recommended test cases.
- Include implementation notes that a developer can directly translate into code or a tool-driven build.

## Implementation Notes

When implementing this project:

1. **Follow Universal Guidelines**: Use the design best practices documented above as your foundation
2. **Apply Project Customizations**: Implement the specific design requirements stated in the "User Design Requirements" section
3. **Priority Order**: Project-specific requirements override universal guidelines when there's a conflict
4. **Color System**: Extract and implement color values as CSS custom properties in RGB format
5. **Typography**: Define font families, sizes, and weights based on specifications
6. **Spacing**: Establish consistent spacing scale following the design system
7. **Components**: Style all Shadcn components to match the design aesthetic
8. **Animations**: Use Motion library for transitions matching the design personality
9. **Responsive Design**: Ensure mobile-first responsive implementation

## Implementation Checklist

- [ ] Review universal design guidelines above
- [ ] Extract project-specific color palette and define CSS variables
- [ ] Configure Tailwind theme with custom colors
- [ ] Set up typography system (fonts, sizes, weights)
- [ ] Define spacing and sizing scales
- [ ] Create component variants matching design
- [ ] Implement responsive breakpoints
- [ ] Add animations and transitions
- [ ] Ensure accessibility standards
- [ ] Validate against user design requirements

---

**Remember: Always reference this file for design decisions. Do not use generic or placeholder designs.**
 for bestpractices and # Email Verification

## Overview
Implement a robust Email Verification system for Archject that securely confirms user email addresses, activates full workspace features, and provides clear, enterprise-ready authentication flows. Features include signed, expiring, one-time-use verification tokens, transactional email delivery via SendGrid, rate-limited resends, and verification status checks on user records. Integrate with existing Login/Signup page and a dedicated Email Verification landing page to guide users through verification, provide next steps, and allow resending links.

## Components to Build
1. Email Verification Service
   - Generate and sign one-time verification tokens with expiry (e.g., 24 hours).
   - Mark user accounts as verified upon token validation.
   - Enforce one-time use by invalidating tokens after successful verification.
   - Persist verification status on the user record and expose status for guards.

2. Email Delivery Integration
   - SendGrid transactional email integration to deliver verification emails.
   - Email templates for: initial verification, verification success, verification expired, and verification link resend.

3. Verification Token Management
   - Token storage (if using server-side token store) or stateless tokens with secure signing and expiry verification.
   - Secure token payload: user_id, issued_at, expiry, purpose (verification), jti (unique token id).

4. Resend Verification Endpoint with Rate Limiting
   - API to request a new verification email.
   - Implement per-user rate limiting (e.g., max 3 requests per 24 hours) and exponential backoff.
   - Optional admin/enforcement controls for enterprise.

5. Frontend Pages
   - page_auth: Unified Login/Signup Page
     - Email/password auth with additional OAuth (Google).
     - Flows for creating/joining workspaces, SSO for enterprise.
   - page_email_verification: Landing page after registration or when user clicks verification link.
     - Validate token from URL, show verification status, provide next steps, allow resending verification link.
     - Clear messaging for success, already-verified, expired, invalid tokens, and guidance for enterprise SSO if applicable.

6. Database Schema Updates
   - User table: verification_status, verification_token_expiry (or rely on token expiry in token payload), last_verification_request_at.
   - Optional: table for tokens if you choose server-side storage.

7. Security & Helpers
   - JWT or similar signed token with expiry and nonce/jti.
   - Verify token signature, expiry, and one-time use constraints.
   - CSRF considerations for tokenful flows on SPA or server-rendered pages.
   - Secure routing guards to block critical actions until verified.

8. Observability & Analytics
   - Logging for token generation, verification attempts, and resends.
   - Metrics: verification email sent, verification success rate, failed verifications, rate-limit blocks.

9. Accessibility & UX
   - Clear success/error states on verification page.
   - Accessible messaging, focus management after actions.
   - Keyboard-friendly flows and readable contrast.

## Implementation Requirements

### Frontend

- UI Components
  - Unified Auth Card: Email/password sign-up and sign-in with OAuth options.
  - Workspace Flow Dialogs: Guided onboarding for creating or joining a workspace.
  - VerificationStatus Banner: Inline status indicators (pending, verified, failed).
  - ResendButton: Debounced, rate-limited button with disabled state during cooldown.
  - Verification Page (page_email_verification)
    - Token-aware URL handling.
    - Messages for: success, already verified, expired, invalid/used token.
    - Countdown or guidance for next steps (e.g., check inbox, resend).
  - Email Verification Form Elements: Email input (for resend) with validation on the page if needed.
  - Global toast/notification system for API feedback.

- Interactions
  - On sign-up, trigger email verification flow and navigate to page_email_verification with token flow.
  - On verification link click, navigate to verification page with token in query string.
  - Resend flow uses rate-limiter feedback (e.g., “Please wait X minutes to resend”).
  - Guard routes to prevent access to critical features until verified (e.g., workspace creation, project actions).

- API Integration
  - Call to /auth/verify/validate (or equivalent) with token from URL.
  - Call to /auth/verify/resend to trigger new verification email.
  - Use Secure cookies / tokens for session management; avoid exposing sensitive data in the URL.

- Styling
  - Apply the project’s design system and color palette provided below.
  - Card-based layouts with consistent padding, typography, and elevation.
  - Focus rings, hover states, and responsive behavior for mobile-first.

### Backend

- API Endpoints
  - POST /auth/register
    - Create user with email/password, create verification token, send verification email.
  - GET /auth/verify?token=<token>
    - Validate token; if valid, mark user as verified; respond with status and redirect URL.
  - POST /auth/verify/resend
    - Trigger a new verification email for the user; enforce rate limiting.
  - POST /auth/login
    - Standard login with email/password; require verified if needed for full workspace access.
  - OAuth endpoints as applicable (Google Sign-In) and enterprise SSO flows.

- Database Schemas
  - User table:
    - id (PK)
    - email (unique)
    - password_hash (hashed)
    - is_verified (boolean, default false)
    - verification_token_jti (string, optional for one-time use)
    - verification_token_expiry (datetime, optional if using token payload)
    - last_verification_requested_at (datetime)
    - workspace_id (FK to workspace)
    - created_at, updated_at
  - Optional: VerificationTokens table
    - id (PK)
    - user_id (FK)
    - token_jti (string)
    - expires_at (datetime)
    - used (boolean)
    - created_at

- Token Service
  - Token generation:
    - Signed token with payload: { sub: user_id, jti, exp: expiry, purpose: "email_verification" }.
  - Verification:
    - Validate signature, expiry, and ensure token not used before (check jti/used flag).
  - One-time use enforcement:
    - Mark token as used upon successful verification or maintain a token store to block replays.

- Email Sending
  - Integrate with SendGrid:
    - Templates:
      - verification_email.html with link: https://yourapp.com/auth/verify?token=<token>
      - resend_notice.html
    - Rate-limiting info and fallback messaging in case of email delivery issues.
  - Email content localization hooks if needed.

- Security
  - Use HTTPS everywhere; secure cookie flags (HttpOnly, Secure, SameSite).
  - Rate limiting per IP/user for resend endpoint (e.g., 3 per 24h; exponential backoff).
  - Token expiry (e.g., 24 hours) and rotation on resends.
  - Do not reveal whether an email is registered during login/signup flows to prevent enumeration.

- Validation
  - Server-side validation of email format on register and resend.
  - Password strength validation on signup.
  - Token validation checks:
    - Signature valid
    - exp > now
    - jti unused
  - Ensure only users with valid workspace context can verify when enterprise SSO is involved.

### Integration

- Flow Orchestration
  - On user signup, create user with is_verified=false, generate verification token, send email, and navigate to page_email_verification.
  - On verification link click, page_email_verification extracts token, calls backend validation endpoint, and upon success, updates UI to show verification success and unlock workspace features.
  - On resend, enforce rate limits, issue new token, and send new email.

- Auth & Guards
  - Protect actions requiring verified email: workspace creation, project approvals, and critical actions.
  - If enterprise SSO is enabled, verification may be prerequisite for SSO access; ensure flows branch accordingly.

- Data Consistency
  - Use a single source of truth for is_verified flag on user record.
  - Ensure token jti is unique per issuance to prevent replay.
  - If a user changes email, invalidate prior verification tokens.

- Observability
  - Instrument endpoints with metrics: requests, successes, failures, latency.
  - Centralized error handling and user-friendly messages.

## User Experience Flow

1. User lands on signup (page_auth) and chooses email/password or Google OAuth.
2. On signup with email:
   - Create user with is_verified = false.
   - Generate verification token (signed, expiry, jti) and store if using a token table.
   - Send verification email via SendGrid with a link to page_email_verification including the token.
   - Redirect user to page_email_verification with a short onboarding message indicating a verification email was sent.
3. User checks email and clicks the verification link.
   - User agent navigates to /auth/verify?token=<token> (SPA or server-rendered).
   - Frontend extracts token and calls backend to validate.
   - Backend validates token; if valid and unused, marks user as is_verified = true, invalidates token jti, and returns success.
   - Frontend shows verification success, explains next steps (enable full workspace features), and redirects to login or automatically logs in user.
4. If user didn’t receive the email:
   - User visits page_email_verification and chooses Resend verification.
   - Backend enforces rate limit; if allowed, issues a new token, updates last_verification_requested_at, and sends a new email.
   - Frontend shows status: “Resent. Check your inbox.”
5. Error states handling:
   - Invalid/expired token: show clear explanation and offer to resend.
   - Already verified: show status and provide quick access to workspace features.
   - Rate limit reached: show cooldown timer and disable resend button until allowed.

## Technical Specifications

- Data Models
  - User: id, email, password_hash, is_verified boolean, created_at, updated_at, last_verification_requested_at
  - VerificationToken (optional if stateless): id, user_id, jti, expires_at, used boolean
- API Endpoints
  - POST /auth/register
  - POST /auth/login
  - GET /auth/verify?token={token}
  - POST /auth/verify/resend
  - GET /auth/oauth/google (and callback)
- Security
  - Token signing algorithm: HS256 or P-256 (prefer RS256 with public key) depending on infrastructure.
  - Token expiry: 24 hours by default; allow rotation via resend.
  - Access control: only unauthenticated users or users in signup flow can access verification endpoints; protected routes require is_verified.
- Validation
  - Email: RFC 5322-ish validation, normalizing to lowercase.
  - Password: minimum length, complexity; provide feedback.
  - Token: signature valid, exp > now, jti unused, purpose == "email_verification"
  - Resend: rate limit per user (e.g., 3 per 24h) and per-IP if needed.

## Acceptance Criteria
- [ ] When a user signs up, a verification email is sent via SendGrid with a valid, expiring token.
- [ ] Visiting /auth/verify?token=<token> redirects to a success state and marks the user as verified; is_verified becomes true and subsequent login/workspace actions unlock.
- [ ] Resend endpoint enforces rate limiting and sends a new verification email when allowed.
- [ ] Tokens are single-use: reusing a token after successful verification or on attempt to reuse results in an invalid/expired message.
- [ ] Verification status is reflected in UI on the login/signup page and verification page with clear next steps.
- [ ] Enterprise/SSO flows gracefully handle verification prerequisites and block/allow access accordingly.
- [ ] All endpoints include appropriate error messages, and API responses are consistent and localized where applicable.

## UI/UX Guidelines

Apply the project's design system:
- Typography and Layout
  - Font family: Inter, SF Pro, or Manrope; weights 400/500/600 as specified.
  - Large bold page titles; section headings medium; body text regular.
  - 24-32px container padding; 16-24px gaps; 8px spacing increments.
- Color Palette
  - Primary: #FFFFFF backgrounds; #195C4A for active navigation and primary actions; #7BE495 for success.
  - Secondary: #F5F6FA / #F7F8FA for cards and inputs.
  - Status: #6B7280 for labels; #FFE8A3 for warnings; #FFDCA8 for in-progress; #FF6C6C for errors.
  - Text: #23272F for headings; #6B7280 for secondary text.
  - Shadows: subtle (#E6E8F0, #D1D5DB) for separation.
- Card Design
  - White cards with soft shadows; 12-16px radius; internal padding ~24px.
  - Hover interactions: light elevation and background shift.
- Navigation
  - Top nav with pill-shaped tabs; active tab in #195C4A.
  - Sidebar optional; bold active item; smooth transitions.
- Interactive Elements
  - Pill buttons; primary actions in deep green; disabled states with lower opacity.
  - Resend button with cooldown and visible timer.
  - Status tags with rounded shapes and bold text.
- Data Visualization
  - Not central to this feature; ensure token/verification statuses feed appropriate UI where charts exist.

---

Connected Pages:
- Login / Signup Page: Unified authentication page allowing teams to sign up or log in with email/password and OAuth (Google). Provides clear flows for workspaces and SSO for enterprise.
- Email Verification Page: Email verification landing page that confirms account/email by validating token from the verification email. Provides next steps and resending verification links.

Technical Notes:
- Prefer a stateless token approach with signed tokens (e.g., JWT) to simplify scaling; if you choose to store tokens, ensure secure storage and a clean TTL with cleanup job.
- Ensure SendGrid API keys and templates are externalized in environment configuration and support per-environment customization.
- Consider support for internationalization if needed; provide fallback English messages.

---

Deliverables
- Fully implemented frontend components and pages with responsive behavior.
- Backend services with endpoints, token handling, email sending, rate limiting, and persistence.
- Database migrations for user_verification fields or dedicated VerificationTokens table.
- Comprehensive tests:
  - Unit tests for token generation/validation.
  - Integration tests for signup, verification flow, and resend with rate limiting.
  - End-to-end test covering the full user journey from signup to verified status.
- Documentation:
  - API docs for verification endpoints.
  - Deployment notes for SendGrid integration, environment variables, and feature flags if necessary.

If you need further granularity on any subcomponent (e.g., exact API payload schemas, token generation code samples, or specific SendGrid template structures), I can provide concrete schemas and code templates. for style.

CRITICAL DESIGN REQUIREMENTS:
- You MUST follow ALL design principles and patterns specified in the Design Reference above
- Do NOT deviate from the design specifications without explicit user permission
- Implement ALL visual design elements (colors, typography, spacing, shadows, animations) as specified
- Follow the layout patterns and component designs exactly as documented
- Ensure all interactions and micro-animations match the reference specifications

CRITICAL TECHNICAL REQUIREMENTS:
- React 18.3.1, React Router 6.30.1
- Tailwind CSS v3 with tailwind.config.js and custom keyframes
- @tailwindcss/typography plugin for rich text content
- Tailwind CSS animations (NOT Motion library or framer-motion)
- Sonner for toasts
- Recharts for data visualization
- Native fetch() with API utilities in src/lib/api.ts
- Design system with CSS custom properties
- Use RGB color values for theming
- When Supabase is configured: use Edge Functions for LLM and server-only logic; never expose API keys in the client

=== TASK ===
# Email Verification

## Overview
Implement a robust Email Verification system for Archject that securely confirms user email addresses, activates full workspace features, and provides clear, enterprise-ready authentication flows. Features include signed, expiring, one-time-use verification tokens, transactional email delivery via SendGrid, rate-limited resends, and verification status checks on user records. Integrate with existing Login/Signup page and a dedicated Email Verification landing page to guide users through verification, provide next steps, and allow resending links.

## Components to Build
1. Email Verification Service
   - Generate and sign one-time verification tokens with expiry (e.g., 24 hours).
   - Mark user accounts as verified upon token validation.
   - Enforce one-time use by invalidating tokens after successful verification.
   - Persist verification status on the user record and expose status for guards.

2. Email Delivery Integration
   - SendGrid transactional email integration to deliver verification emails.
   - Email templates for: initial verification, verification success, verification expired, and verification link resend.

3. Verification Token Management
   - Token storage (if using server-side token store) or stateless tokens with secure signing and expiry verification.
   - Secure token payload: user_id, issued_at, expiry, purpose (verification), jti (unique token id).

4. Resend Verification Endpoint with Rate Limiting
   - API to request a new verification email.
   - Implement per-user rate limiting (e.g., max 3 requests per 24 hours) and exponential backoff.
   - Optional admin/enforcement controls for enterprise.

5. Frontend Pages
   - page_auth: Unified Login/Signup Page
     - Email/password auth with additional OAuth (Google).
     - Flows for creating/joining workspaces, SSO for enterprise.
   - page_email_verification: Landing page after registration or when user clicks verification link.
     - Validate token from URL, show verification status, provide next steps, allow resending verification link.
     - Clear messaging for success, already-verified, expired, invalid tokens, and guidance for enterprise SSO if applicable.

6. Database Schema Updates
   - User table: verification_status, verification_token_expiry (or rely on token expiry in token payload), last_verification_request_at.
   - Optional: table for tokens if you choose server-side storage.

7. Security & Helpers
   - JWT or similar signed token with expiry and nonce/jti.
   - Verify token signature, expiry, and one-time use constraints.
   - CSRF considerations for tokenful flows on SPA or server-rendered pages.
   - Secure routing guards to block critical actions until verified.

8. Observability & Analytics
   - Logging for token generation, verification attempts, and resends.
   - Metrics: verification email sent, verification success rate, failed verifications, rate-limit blocks.

9. Accessibility & UX
   - Clear success/error states on verification page.
   - Accessible messaging, focus management after actions.
   - Keyboard-friendly flows and readable contrast.

## Implementation Requirements

### Frontend

- UI Components
  - Unified Auth Card: Email/password sign-up and sign-in with OAuth options.
  - Workspace Flow Dialogs: Guided onboarding for creating or joining a workspace.
  - VerificationStatus Banner: Inline status indicators (pending, verified, failed).
  - ResendButton: Debounced, rate-limited button with disabled state during cooldown.
  - Verification Page (page_email_verification)
    - Token-aware URL handling.
    - Messages for: success, already verified, expired, invalid/used token.
    - Countdown or guidance for next steps (e.g., check inbox, resend).
  - Email Verification Form Elements: Email input (for resend) with validation on the page if needed.
  - Global toast/notification system for API feedback.

- Interactions
  - On sign-up, trigger email verification flow and navigate to page_email_verification with token flow.
  - On verification link click, navigate to verification page with token in query string.
  - Resend flow uses rate-limiter feedback (e.g., “Please wait X minutes to resend”).
  - Guard routes to prevent access to critical features until verified (e.g., workspace creation, project actions).

- API Integration
  - Call to /auth/verify/validate (or equivalent) with token from URL.
  - Call to /auth/verify/resend to trigger new verification email.
  - Use Secure cookies / tokens for session management; avoid exposing sensitive data in the URL.

- Styling
  - Apply the project’s design system and color palette provided below.
  - Card-based layouts with consistent padding, typography, and elevation.
  - Focus rings, hover states, and responsive behavior for mobile-first.

### Backend

- API Endpoints
  - POST /auth/register
    - Create user with email/password, create verification token, send verification email.
  - GET /auth/verify?token=<token>
    - Validate token; if valid, mark user as verified; respond with status and redirect URL.
  - POST /auth/verify/resend
    - Trigger a new verification email for the user; enforce rate limiting.
  - POST /auth/login
    - Standard login with email/password; require verified if needed for full workspace access.
  - OAuth endpoints as applicable (Google Sign-In) and enterprise SSO flows.

- Database Schemas
  - User table:
    - id (PK)
    - email (unique)
    - password_hash (hashed)
    - is_verified (boolean, default false)
    - verification_token_jti (string, optional for one-time use)
    - verification_token_expiry (datetime, optional if using token payload)
    - last_verification_requested_at (datetime)
    - workspace_id (FK to workspace)
    - created_at, updated_at
  - Optional: VerificationTokens table
    - id (PK)
    - user_id (FK)
    - token_jti (string)
    - expires_at (datetime)
    - used (boolean)
    - created_at

- Token Service
  - Token generation:
    - Signed token with payload: { sub: user_id, jti, exp: expiry, purpose: "email_verification" }.
  - Verification:
    - Validate signature, expiry, and ensure token not used before (check jti/used flag).
  - One-time use enforcement:
    - Mark token as used upon successful verification or maintain a token store to block replays.

- Email Sending
  - Integrate with SendGrid:
    - Templates:
      - verification_email.html with link: https://yourapp.com/auth/verify?token=<token>
      - resend_notice.html
    - Rate-limiting info and fallback messaging in case of email delivery issues.
  - Email content localization hooks if needed.

- Security
  - Use HTTPS everywhere; secure cookie flags (HttpOnly, Secure, SameSite).
  - Rate limiting per IP/user for resend endpoint (e.g., 3 per 24h; exponential backoff).
  - Token expiry (e.g., 24 hours) and rotation on resends.
  - Do not reveal whether an email is registered during login/signup flows to prevent enumeration.

- Validation
  - Server-side validation of email format on register and resend.
  - Password strength validation on signup.
  - Token validation checks:
    - Signature valid
    - exp > now
    - jti unused
  - Ensure only users with valid workspace context can verify when enterprise SSO is involved.

### Integration

- Flow Orchestration
  - On user signup, create user with is_verified=false, generate verification token, send email, and navigate to page_email_verification.
  - On verification link click, page_email_verification extracts token, calls backend validation endpoint, and upon success, updates UI to show verification success and unlock workspace features.
  - On resend, enforce rate limits, issue new token, and send new email.

- Auth & Guards
  - Protect actions requiring verified email: workspace creation, project approvals, and critical actions.
  - If enterprise SSO is enabled, verification may be prerequisite for SSO access; ensure flows branch accordingly.

- Data Consistency
  - Use a single source of truth for is_verified flag on user record.
  - Ensure token jti is unique per issuance to prevent replay.
  - If a user changes email, invalidate prior verification tokens.

- Observability
  - Instrument endpoints with metrics: requests, successes, failures, latency.
  - Centralized error handling and user-friendly messages.

## User Experience Flow

1. User lands on signup (page_auth) and chooses email/password or Google OAuth.
2. On signup with email:
   - Create user with is_verified = false.
   - Generate verification token (signed, expiry, jti) and store if using a token table.
   - Send verification email via SendGrid with a link to page_email_verification including the token.
   - Redirect user to page_email_verification with a short onboarding message indicating a verification email was sent.
3. User checks email and clicks the verification link.
   - User agent navigates to /auth/verify?token=<token> (SPA or server-rendered).
   - Frontend extracts token and calls backend to validate.
   - Backend validates token; if valid and unused, marks user as is_verified = true, invalidates token jti, and returns success.
   - Frontend shows verification success, explains next steps (enable full workspace features), and redirects to login or automatically logs in user.
4. If user didn’t receive the email:
   - User visits page_email_verification and chooses Resend verification.
   - Backend enforces rate limit; if allowed, issues a new token, updates last_verification_requested_at, and sends a new email.
   - Frontend shows status: “Resent. Check your inbox.”
5. Error states handling:
   - Invalid/expired token: show clear explanation and offer to resend.
   - Already verified: show status and provide quick access to workspace features.
   - Rate limit reached: show cooldown timer and disable resend button until allowed.

## Technical Specifications

- Data Models
  - User: id, email, password_hash, is_verified boolean, created_at, updated_at, last_verification_requested_at
  - VerificationToken (optional if stateless): id, user_id, jti, expires_at, used boolean
- API Endpoints
  - POST /auth/register
  - POST /auth/login
  - GET /auth/verify?token={token}
  - POST /auth/verify/resend
  - GET /auth/oauth/google (and callback)
- Security
  - Token signing algorithm: HS256 or P-256 (prefer RS256 with public key) depending on infrastructure.
  - Token expiry: 24 hours by default; allow rotation via resend.
  - Access control: only unauthenticated users or users in signup flow can access verification endpoints; protected routes require is_verified.
- Validation
  - Email: RFC 5322-ish validation, normalizing to lowercase.
  - Password: minimum length, complexity; provide feedback.
  - Token: signature valid, exp > now, jti unused, purpose == "email_verification"
  - Resend: rate limit per user (e.g., 3 per 24h) and per-IP if needed.

## Acceptance Criteria
- [ ] When a user signs up, a verification email is sent via SendGrid with a valid, expiring token.
- [ ] Visiting /auth/verify?token=<token> redirects to a success state and marks the user as verified; is_verified becomes true and subsequent login/workspace actions unlock.
- [ ] Resend endpoint enforces rate limiting and sends a new verification email when allowed.
- [ ] Tokens are single-use: reusing a token after successful verification or on attempt to reuse results in an invalid/expired message.
- [ ] Verification status is reflected in UI on the login/signup page and verification page with clear next steps.
- [ ] Enterprise/SSO flows gracefully handle verification prerequisites and block/allow access accordingly.
- [ ] All endpoints include appropriate error messages, and API responses are consistent and localized where applicable.

## UI/UX Guidelines

Apply the project's design system:
- Typography and Layout
  - Font family: Inter, SF Pro, or Manrope; weights 400/500/600 as specified.
  - Large bold page titles; section headings medium; body text regular.
  - 24-32px container padding; 16-24px gaps; 8px spacing increments.
- Color Palette
  - Primary: #FFFFFF backgrounds; #195C4A for active navigation and primary actions; #7BE495 for success.
  - Secondary: #F5F6FA / #F7F8FA for cards and inputs.
  - Status: #6B7280 for labels; #FFE8A3 for warnings; #FFDCA8 for in-progress; #FF6C6C for errors.
  - Text: #23272F for headings; #6B7280 for secondary text.
  - Shadows: subtle (#E6E8F0, #D1D5DB) for separation.
- Card Design
  - White cards with soft shadows; 12-16px radius; internal padding ~24px.
  - Hover interactions: light elevation and background shift.
- Navigation
  - Top nav with pill-shaped tabs; active tab in #195C4A.
  - Sidebar optional; bold active item; smooth transitions.
- Interactive Elements
  - Pill buttons; primary actions in deep green; disabled states with lower opacity.
  - Resend button with cooldown and visible timer.
  - Status tags with rounded shapes and bold text.
- Data Visualization
  - Not central to this feature; ensure token/verification statuses feed appropriate UI where charts exist.

---

Connected Pages:
- Login / Signup Page: Unified authentication page allowing teams to sign up or log in with email/password and OAuth (Google). Provides clear flows for workspaces and SSO for enterprise.
- Email Verification Page: Email verification landing page that confirms account/email by validating token from the verification email. Provides next steps and resending verification links.

Technical Notes:
- Prefer a stateless token approach with signed tokens (e.g., JWT) to simplify scaling; if you choose to store tokens, ensure secure storage and a clean TTL with cleanup job.
- Ensure SendGrid API keys and templates are externalized in environment configuration and support per-environment customization.
- Consider support for internationalization if needed; provide fallback English messages.

---

Deliverables
- Fully implemented frontend components and pages with responsive behavior.
- Backend services with endpoints, token handling, email sending, rate limiting, and persistence.
- Database migrations for user_verification fields or dedicated VerificationTokens table.
- Comprehensive tests:
  - Unit tests for token generation/validation.
  - Integration tests for signup, verification flow, and resend with rate limiting.
  - End-to-end test covering the full user journey from signup to verified status.
- Documentation:
  - API docs for verification endpoints.
  - Deployment notes for SendGrid integration, environment variables, and feature flags if necessary.

If you need further granularity on any subcomponent (e.g., exact API payload schemas, token generation code samples, or specific SendGrid template structures), I can provide concrete schemas and code templates.

=== SUCCESS CRITERIA ===
# Success Criteria Checklist

## Code Quality

### TypeScript
- [ ] No TypeScript errors (`tsc --noEmit` passes)
- [ ] All functions and components have proper type definitions
- [ ] No `any` types used (use `unknown` if type is truly unknown)
- [ ] Props interfaces defined for all components
- [ ] API responses have type definitions

### Code Standards
- [ ] All imports use path aliases (@/ prefix)
- [ ] Components follow the established naming convention
- [ ] Files are organized in correct directories
- [ ] No unused imports or variables
- [ ] Consistent code formatting

## Component Implementation

### UI Components
- [ ] Use shadcn/ui components (Button, Card, Input, etc.) instead of building from scratch
- [ ] All interactive elements have hover states
- [ ] Components use the `cn()` utility for class merging
- [ ] Proper TypeScript props interfaces defined
- [ ] Components are responsive (mobile, tablet, desktop)

### Animations
- [ ] Motion library used for all animations (NOT framer-motion)
- [ ] Page transitions implemented with fade/slide
- [ ] Interactive elements have whileHover/whileTap animations
- [ ] List items use stagger animations where appropriate
- [ ] Animations respect `prefers-reduced-motion`

### Icons
- [ ] Lucide React icons used consistently
- [ ] Icons have consistent sizing (h-4 w-4, h-5 w-5, h-6 w-6)
- [ ] Icon colors match design system (text-primary, text-muted-foreground)

## Data Management

### React Query
- [ ] All data fetching uses React Query hooks
- [ ] Query keys follow the established pattern
- [ ] Mutations invalidate related queries
- [ ] Loading and error states handled
- [ ] Optimistic updates implemented where appropriate

### Forms
- [ ] Forms use react-hook-form
- [ ] Validation uses Zod schemas
- [ ] Error messages display properly
- [ ] Form submission shows loading state
- [ ] Success/error feedback via toast notifications

### API Layer
- [ ] API functions in src/api/ directory
- [ ] Axios used for HTTP requests
- [ ] Proper error handling with try/catch
- [ ] Auth tokens handled by interceptors
- [ ] Type-safe API function signatures

## User Experience

### Notifications
- [ ] Sonner toasts used for all notifications
- [ ] Success actions show success toast
- [ ] Errors show descriptive error messages
- [ ] Loading states show toast.loading()

### Loading States
- [ ] Skeleton loaders shown during data fetch
- [ ] Buttons show loading state during submission
- [ ] Disabled state applied during async operations

### Error Handling
- [ ] Network errors caught and displayed
- [ ] User-friendly error messages (no stack traces)
- [ ] Fallback UI for error states
- [ ] No unhandled promise rejections

## Navigation

### Route Accessibility
- [ ] All pages have routes defined in router configuration
- [ ] Every page is accessible through navigation (menu, sidebar, or direct URL)
- [ ] Main pages (Dashboard, Home, Settings, etc.) accessible from primary navigation
- [ ] Secondary pages accessible through contextual navigation or direct links
- [ ] Deep-linked pages have breadcrumbs or back navigation
- [ ] 404/Not Found page implemented for invalid routes
- [ ] Protected routes have proper authentication checks
- [ ] Navigation state persists across page refreshes where appropriate

### Navigation UX
- [ ] Active route highlighted in navigation menu
- [ ] Clear visual hierarchy in navigation structure
- [ ] Mobile navigation is accessible and usable
- [ ] Navigation items have hover/focus states
- [ ] Nested routes show parent-child relationships
- [ ] User can always return to main areas (Dashboard/Home)

## Styling

### Tailwind CSS
- [ ] Tailwind v3 classes used
- [ ] HSL color variables from design system
- [ ] Custom CSS properties used where defined
- [ ] Responsive breakpoints: mobile-first approach
- [ ] Dark mode support via CSS variables

### Design System
- [ ] Colors use theme variables (primary, secondary, accent)
- [ ] Spacing uses Tailwind scale (p-4, gap-6, etc.)
- [ ] Border radius uses theme values (rounded-lg)
- [ ] Shadows use theme values (shadow-card)
- [ ] Typography follows Inter font system

## Accessibility

- [ ] Semantic HTML elements used
- [ ] Buttons have descriptive labels
- [ ] Forms have proper labels
- [ ] Focus states visible on interactive elements
- [ ] Color contrast meets WCAG standards

## Performance

- [ ] No console.log statements in production code
- [ ] No console errors in browser
- [ ] Images optimized (WebP, lazy loading)
- [ ] Large lists use virtualization if needed
- [ ] React Query cache configured appropriately

## Testing Readiness

- [ ] Components structured for easy testing
- [ ] Business logic separated from presentation
- [ ] Mock-friendly API layer
- [ ] No hardcoded values that should be configurable
- [ ] Environment variables properly configured

## Final Checks

- [ ] Code builds without errors (`npm run build`)
- [ ] Development server runs without errors (`npm run dev`)
- [ ] No TypeScript errors in editor
- [ ] Browser console is clean (no errors or warnings)
- [ ] All functionality works as expected
- [ ] Code follows existing project patterns
- [ ] Changes are consistent with the rest of the codebase



IMPORTANT: ALL styling and design decisions must follow the Design Reference section above EXACTLY. Do not make arbitrary design choices.

Analyze the existing project structure and implement the task following the patterns already established. Ensure all success criteria are met.