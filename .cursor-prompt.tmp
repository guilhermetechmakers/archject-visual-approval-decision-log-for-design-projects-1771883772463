⚠️ CRITICAL EXECUTION RULES - READ FIRST ⚠️
❌ NEVER run: npm run dev, npm start, yarn dev, pnpm dev, or ANY development server
❌ NEVER run: long-running processes, servers, or commands that don't exit
❌ NEVER test the application by starting it
✅ ALLOWED: npm install, npm run build, npm run test (if needed)
✅ YOUR TASK: Create/modify files only, then STOP and EXIT immediately
⚠️ The MCP server handles all testing and validation separately

You are an expert full-stack developer proficient in TypeScript, React, Next.js, and modern UI/UX frameworks (Tailwind CSS, Shadcn UI, Radix UI).

=== DESIGN REFERENCE (MANDATORY) ===
# Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions


*IMPORTANT*: For every page or component refer to # Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions
 for bestpractices and # Billing / Subscription Page

## Overview
Build a cohesive Billing / Subscription experience for Archject that enables users to manage their subscription, view/download invoices, update payment methods via Stripe, and upgrade/downgrade plans. This page integrates with the Payment & Billing subsystem (Stripe-based) and connects with Settings / Preferences and Checkout / Payment flows. The project should deliver a polished, accessible, mobile-first UI that matches Archject’s design system, ensuring clear auditability, secure payments, and seamless user experience across subscription management, invoicing, and add-on purchases.

## Page Description (Full Detail)
What this page is:
- A comprehensive Billing / Subscription page for Archject that consolidates subscription management, invoices, and payment method management in one accessible interface. It also provides upgrade/downgrade flows, proration details, and add-on purchases.

Goals:
- Allow users to:
  - View current plan, tier limits, usage meters, next billing date, and renewal status.
  - Change plans (upgrade/downgrade) with visible prorations and impact.
  - Manage payment methods securely via Stripe (add, update, set default).
  - View a historical invoice list with downloadable PDFs, dates, amounts, and statuses.
  - Purchase add-ons (e.g., PDF exports, enterprise integrations, priority support) with associated invoices/receipts.
  - Navigate to Checkout / Payment flow for any add-on or subscription change requiring payment collection.
- Ensure data integrity, clear auditability, and easy exports where applicable.
- Maintain visual and interaction consistency with Archject’s UI system, including navigation, cards, typography, and color usage.

Connected features:
- Payment & Billing: Stripe-based subscription management, billing, invoices, and add-on purchases.
- Connected Pages: Settings / Preferences (billing config, API keys, workspace export), Landing Page (marketing flow and CTAs), Checkout / Payment Page (secure checkout for subscriptions/add-ons).

UI guidance and visual details:
- Present a Current Plan card with plan name, limits, next billing date, usage meters, and actions (Change Plan).
- Provide a Plan Change modal/dialog with prorations, billing impact, and confirmation flow.
- Include a Payment Method section with a Stripe-based form to add/update cards, set default, and last4 display.
- Invoices section with a sortable/searchable table listing date, invoice number, amount, status, and a download PDF action.
- Add-ons section to browse/purchase additional capabilities; show price, features, and a purchase CTA leading to Checkout.
- All sections should live within clean, white cards on very light gray backgrounds; use generous padding, clear typography, and accessible color contrasts.

Visual guidance:
- Align with the provided color palette and typography, ensuring consistency with the design system (cards, shadows, hover states, focus rings, and responsive behavior).
- Use 12–16px card radii, 24px internal padding, and 8px spacing increments.
- Primary actions use deep green (#195C4A); success indicators use Bright green (#7BE495); alerts use soft yellow (#FFE8A3) and muted orange (#FFDCA8); destructive actions use light red (#FF6C6C).

## Components to Build
- Current Plan Card
  - Plan name, tier, features/limits, usage meters, next billing date, billing cycle, renewal status.
  - Actions: Change Plan (opens modal with plan options and proration explanation).
- Plan Change Modal
  - Available plans, prorated cost, impact on renewal date, estimated bill, confirm/cancel actions.
- Payment Method Section
  - Card form integrated with Stripe Elements (or Payment Intent-based method collection).
  - Display last4, card brand, expiration, default status, and actions to update or remove.
- Invoices Table
  - Columns: Invoice Date, Invoice Number, Amount, Status, PDF Download.
  - Features: Pagination, search, filter by date/status, sort.
- Add-ons Section
  - Catalog/list of add-ons with descriptions, prices, and purchase CTA.
  - Purchase flow redirects to Checkout / Payment Page as needed.
- Checkout / Payment Flow (shared with Checkout page)
  - Order summary (subscription or add-on), coupon entry, tax estimation (if applicable), secure payment collection, and final confirmation.
- Quick Export / Data Export (where applicable)
  - Button to export invoices or decision-related records as PDF/CSV for records export (aligned with business needs).
- Notifications / Help
  - Inline help texts, status badges, success/error toasts, and accessible tooltips.

## Implementation Requirements

### Frontend
- Pages:
  - Billing / Subscription Page (main)
  - Plan Change Modal
  - Payment Method management UI
  - Invoices interface (list and detail view as needed)
  - Add-ons catalog view
  - Checkout / Payment Page (shared component or route, used for add-ons and plan adjustments)
- Components:
  - Card components with elevation, header, body, and actions
  - Button variants: primary (solid deep green), secondary/ghost, and destructive
  - Form controls: input fields, select menus, and Stripe Elements integration
  - Tables with sorting, filtering, and pagination
  - Tabs or segmented controls for navigation within the Billing area
  - Status chips (e.g., Paid, Due, Overdue)
  - Meters/progress bars for usage limits
  - Modals/Drawer for plan changes
  - Toast notifications for success/failure
- Data handling:
  - Fetch current subscription, next billing date, used limits, and current payment method
  - Fetch invoice list with pagination and download links
  - Fetch available add-ons and plan options
  - Trigger checkout flow with a review pane and coupon application
- Accessibility:
  - All interactive elements accessible via keyboard
  - ARIA labels for dynamic content
  - High-contrast focus rings and proper labeling
- Responsiveness:
  - Mobile-first layout with responsive grid that collapses to single-column cards on small screens
  - Tables should be horizontally scrollable on small viewports if needed

### Backend
- APIs to support:
  - GET /billing/subscription: Retrieve current plan, status, next billing date, usage meters, and payment method
  - GET /billing/invoices: Retrieve invoice list with pagination, date, amount, status, and download URL
  - POST /billing/change-plan: Initiate plan change with selected plan and return proration estimates
  - POST /billing/payment-method: Add or update Stripe payment method (tokenization via Stripe)
  - GET /billing/addons: List available add-ons with pricing
  - POST /billing/purchase-addon: Create checkout session or invoice for add-ons
  - POST /billing/apply-coupon: Validate and apply coupon to current or upcoming invoice
  - POST /checkout/session: Create a secure Stripe Checkout session for subscription/add-on
  - GET /billing/export: Generate exportable invoices or decision logs as PDF/CSV
- Database considerations:
  - Tables/collections for Subscriptions, Plans, Invoices, PaymentMethods, AddOns, Coupons
  - Audit fields: created_at, updated_at, last_modified_by
  - Indexes on user_id, subscription_id, invoice_date for performance
- Stripe integration:
  - Use Stripe Customer, Payment Methods, Subscriptions, Invoices as appropriate
  - Support plan proration, prorations display in Plan Change flow
  - Securely handle payment method tokens; do not store full card numbers
  - Webhook handling for invoice.payment_succeeded/failed, subscription.updated, and payment_intent.succeeded
- Validation:
  - Server-side validation for plan eligibility, add-on availability, coupon validity, and correct user ownership
  - Ensure idempotency for checkout/session creation

### Integration
- Data flow:
  - Billing page fetches user subscription and invoices from backend; UI updates with actions
  - Plan Change modal triggers backend plan-change process; reflect prorations
  - Payment Method form communicates with Stripe via backend endpoints
  - Add-ons purchase routes funnel to Checkout / Payment Page with a summary and coupon entry
  - Invoices download uses generated PDFs stored or generated on-the-fly by backend
- Connected pages integration:
  - Settings / Preferences: Billing-related settings reflect in the Billing page (billing exposure, export options)
  - Checkout / Payment Page: Central secure path for payment, shared with subscription changes and add-ons
  - Landing Page: CTAs for signup/demo will route to Checkout where appropriate or to onboarding flows

## User Experience Flow
- User signs in and lands on Billing / Subscription Page
  1. View current plan card with limits, usage meters, next billing date, and renewal status
  2. Click Change Plan to open modal; review proration details; confirm plan switch
  3. Manage Payment Method:
     - Open Payment Method section; add/update card via Stripe; set default payment method
     - See masked card details and last4; confirm changes
  4. Invoices:
     - Browse list; view details; download PDF invoices; filter by date/status
  5. Add-ons:
     - Review available add-ons; click Buy to open Checkout flow
     - In Checkout, review order summary, apply coupon, complete secure payment
  6. Exit or continue to export data if needed (PDF/CSV)
- Edge cases:
  - Failed payments: show actionable error, allow update of payment method
  - Proration explanations: clearly present impact when upgrading/downgrading mid-cycle
  - Coupon invalid/expired: display friendly error with guidance
  - Add-on out-of-stock or unavailable: gracefully handle and provide alternatives

## Technical Specifications

Data Models:
- User
- Subscription: { id, user_id, plan_id, status, current_period_start, current_period_end, next_billing_date, quantity, trial_period_end, prorated_amount }
- Plan: { id, name, price, interval (monthly/yearly), features, limits: { usage, seats, storage }, is_active }
- Invoice: { id, subscription_id, invoice_date, amount_due, currency, status, pdf_url, pdf_generated_at }
- PaymentMethod: { id, user_id, stripe_payment_method_id, brand, last4, exp_month, exp_year, is_default }
- AddOn: { id, name, description, price, currency, interval, features }
- Coupon: { id, code, discount_type, amount_off, percent_off, valid_until, applies_to_plan_ids, max_uses }

API Endpoints (examples):
- GET /api/billing/subscription
- GET /api/billing/invoices?page=&limit=&status=
- POST /api/billing/change-plan
- POST /api/billing/payment-method
- GET /api/billing/addons
- POST /api/billing/purchase-addon
- POST /api/billing/apply-coupon
- POST /api/checkout/session
- GET /api/billing/export

Security:
- Authentication: JWT or session-based auth; require valid user token
- Authorization: Ensure user owns the subscription and invoices
- PCI compliance: Stripe handles card data; never store full card numbers
- Webhooks: Validate Stripe webhook signatures; idempotent processing

Validation:
- Frontend: required fields; format checks; valid coupon codes; date picks; numeric inputs
- Backend: verify user ownership; validate plan compatibility; ensure coupon validity; idempotent operations for checkout

## Acceptance Criteria
- [ ] Billing / Subscription Page loads with current plan, next billing date, usage meters, and a list of invoices
- [ ] Change Plan flow shows prorations; selecting a plan updates the subscription via backend and reflects in UI
- [ ] Payment Method management supports adding/updating Stripe card, with default indicator and secure storage
- [ ] Invoices table displays all invoices with date, amount, status, and downloadable PDF; pagination/search/sort works
- [ ] Add-ons catalog loads; purchasing an add-on redirects to Checkout and completes payment securely
- [ ] Checkout / Payment Page handles subscription and add-ons with order summary, coupon entry, and Stripe payment collection
- [ ] Webhook handling for payment events updates internal records accordingly
- [ ] Accessibility and responsive behavior meet WCAG 2.1 AA standards
- [ ] UI aligns with the design system: colors, typography, cards, shadows, spacing

## UI/UX Guidelines
Apply the project's design system:
- Cards with white background, subtle shadows, 12–16px radii
- Top navigation and secondary navigation consistent with Archject
- Pill-shaped primary actions in deep green
- Soft, readable typography with Inter/SF Pro/Manrope-like font
- Left-aligned content, generous whitespace, consistent 8px spacing increments
- Hover/focus states: elevation, color shifts, focus rings
- Data visualization notes: if charts appear (usage/meters), use clean lines and muted axes

## Visual Style

 Color Palette (as provided):
- Primary: Soft white (#FFFFFF)
- Secondary: Very light gray (#F5F6FA, #F7F8FA)
- Accent Colors:
  - Deep green (#195C4A) for active navigation and primary actions
  - Bright green (#7BE495) for success indicators
  - Soft yellow (#FFE8A3) and muted orange (#FFDCA8) for warnings/in-progress
  - Light red (#FF6C6C) for destructive actions and overdue
- Text:
  - Dark gray (#23272F)
  - Medium gray (#6B7280)
- Subtle borders/shadows: #E6E8F0, #D1D5DB
- Typography:
  - Font family: Inter / SF Pro / Manrope-like
  - Weights: 400 body, 500 labels/navigation, 600 headings/actions
- Layout: 24–32px container padding; 16–24px gaps; 8px increments
- Card styling: white background, soft box shadow (0 4px 16px rgba(34, 42, 89, 0.05)), 12–16px radius
- Interaction: hover elevations, color shifts, focus rings

Design Philosophy:
- Modern, minimal, professional; accessible and intuitive
- Clear hierarchy, trust, and data ownership
- Mobile-first, responsive, and distraction-free surfaces

Connected Pages/Features:
- Settings / Preferences: Billing-related settings, branding, integrations, API keys, data export
- Landing Page: Marketing content with pricing and CTAs
- Checkout / Payment Page: Secure checkout flow for subscriptions/add-ons

Notes for AI development tool:
- Model should generate code scaffolds, components, and API contracts aligned to the specified structures.
- Include data mocks and example API payloads for testing.
- Provide clear separation between frontend components and backend API definitions, with type definitions (e.g., TypeScript interfaces) and API schema (OpenAPI-like) as outputs.
- Produce a structured repo layout suggestion (folders for frontend pages, components, hooks, services, and backend routes/controllers).
- Include unit tests stubs for key components and integration tests outline for end-to-end flows with Stripe simulation.

Generated deliverable should include:
- Detailed UI component specs and wireframes (descriptions sufficient for implementation)
- API contracts with request/response schemas
- Frontend component tree and state management plan
- Backend service/module outlines with data models and Stripe integration steps
- Access control and security notes
- Acceptance test plan with concrete test cases and expected outcomes

If you need me to tailor to a specific frontend framework (e.g., React + Next.js) or a backend stack (e.g., Node/Express, NestJS, or Python FastAPI), I can adapt the prompt with precise code scaffolding and file templates. for style.

CRITICAL DESIGN REQUIREMENTS:
- You MUST follow ALL design principles and patterns specified in the Design Reference above
- Do NOT deviate from the design specifications without explicit user permission
- Implement ALL visual design elements (colors, typography, spacing, shadows, animations) as specified
- Follow the layout patterns and component designs exactly as documented
- Ensure all interactions and micro-animations match the reference specifications

CRITICAL TECHNICAL REQUIREMENTS:
- React 18.3.1, React Router 6.30.1
- Tailwind CSS v3 with tailwind.config.js and custom keyframes
- @tailwindcss/typography plugin for rich text content
- Tailwind CSS animations (NOT Motion library or framer-motion)
- Sonner for toasts
- Recharts for data visualization
- Native fetch() with API utilities in src/lib/api.ts
- Design system with CSS custom properties
- Use RGB color values for theming
- When Supabase is configured: use Edge Functions for LLM and server-only logic; never expose API keys in the client

=== TASK ===
# Billing / Subscription Page

## Overview
Build a cohesive Billing / Subscription experience for Archject that enables users to manage their subscription, view/download invoices, update payment methods via Stripe, and upgrade/downgrade plans. This page integrates with the Payment & Billing subsystem (Stripe-based) and connects with Settings / Preferences and Checkout / Payment flows. The project should deliver a polished, accessible, mobile-first UI that matches Archject’s design system, ensuring clear auditability, secure payments, and seamless user experience across subscription management, invoicing, and add-on purchases.

## Page Description (Full Detail)
What this page is:
- A comprehensive Billing / Subscription page for Archject that consolidates subscription management, invoices, and payment method management in one accessible interface. It also provides upgrade/downgrade flows, proration details, and add-on purchases.

Goals:
- Allow users to:
  - View current plan, tier limits, usage meters, next billing date, and renewal status.
  - Change plans (upgrade/downgrade) with visible prorations and impact.
  - Manage payment methods securely via Stripe (add, update, set default).
  - View a historical invoice list with downloadable PDFs, dates, amounts, and statuses.
  - Purchase add-ons (e.g., PDF exports, enterprise integrations, priority support) with associated invoices/receipts.
  - Navigate to Checkout / Payment flow for any add-on or subscription change requiring payment collection.
- Ensure data integrity, clear auditability, and easy exports where applicable.
- Maintain visual and interaction consistency with Archject’s UI system, including navigation, cards, typography, and color usage.

Connected features:
- Payment & Billing: Stripe-based subscription management, billing, invoices, and add-on purchases.
- Connected Pages: Settings / Preferences (billing config, API keys, workspace export), Landing Page (marketing flow and CTAs), Checkout / Payment Page (secure checkout for subscriptions/add-ons).

UI guidance and visual details:
- Present a Current Plan card with plan name, limits, next billing date, usage meters, and actions (Change Plan).
- Provide a Plan Change modal/dialog with prorations, billing impact, and confirmation flow.
- Include a Payment Method section with a Stripe-based form to add/update cards, set default, and last4 display.
- Invoices section with a sortable/searchable table listing date, invoice number, amount, status, and a download PDF action.
- Add-ons section to browse/purchase additional capabilities; show price, features, and a purchase CTA leading to Checkout.
- All sections should live within clean, white cards on very light gray backgrounds; use generous padding, clear typography, and accessible color contrasts.

Visual guidance:
- Align with the provided color palette and typography, ensuring consistency with the design system (cards, shadows, hover states, focus rings, and responsive behavior).
- Use 12–16px card radii, 24px internal padding, and 8px spacing increments.
- Primary actions use deep green (#195C4A); success indicators use Bright green (#7BE495); alerts use soft yellow (#FFE8A3) and muted orange (#FFDCA8); destructive actions use light red (#FF6C6C).

## Components to Build
- Current Plan Card
  - Plan name, tier, features/limits, usage meters, next billing date, billing cycle, renewal status.
  - Actions: Change Plan (opens modal with plan options and proration explanation).
- Plan Change Modal
  - Available plans, prorated cost, impact on renewal date, estimated bill, confirm/cancel actions.
- Payment Method Section
  - Card form integrated with Stripe Elements (or Payment Intent-based method collection).
  - Display last4, card brand, expiration, default status, and actions to update or remove.
- Invoices Table
  - Columns: Invoice Date, Invoice Number, Amount, Status, PDF Download.
  - Features: Pagination, search, filter by date/status, sort.
- Add-ons Section
  - Catalog/list of add-ons with descriptions, prices, and purchase CTA.
  - Purchase flow redirects to Checkout / Payment Page as needed.
- Checkout / Payment Flow (shared with Checkout page)
  - Order summary (subscription or add-on), coupon entry, tax estimation (if applicable), secure payment collection, and final confirmation.
- Quick Export / Data Export (where applicable)
  - Button to export invoices or decision-related records as PDF/CSV for records export (aligned with business needs).
- Notifications / Help
  - Inline help texts, status badges, success/error toasts, and accessible tooltips.

## Implementation Requirements

### Frontend
- Pages:
  - Billing / Subscription Page (main)
  - Plan Change Modal
  - Payment Method management UI
  - Invoices interface (list and detail view as needed)
  - Add-ons catalog view
  - Checkout / Payment Page (shared component or route, used for add-ons and plan adjustments)
- Components:
  - Card components with elevation, header, body, and actions
  - Button variants: primary (solid deep green), secondary/ghost, and destructive
  - Form controls: input fields, select menus, and Stripe Elements integration
  - Tables with sorting, filtering, and pagination
  - Tabs or segmented controls for navigation within the Billing area
  - Status chips (e.g., Paid, Due, Overdue)
  - Meters/progress bars for usage limits
  - Modals/Drawer for plan changes
  - Toast notifications for success/failure
- Data handling:
  - Fetch current subscription, next billing date, used limits, and current payment method
  - Fetch invoice list with pagination and download links
  - Fetch available add-ons and plan options
  - Trigger checkout flow with a review pane and coupon application
- Accessibility:
  - All interactive elements accessible via keyboard
  - ARIA labels for dynamic content
  - High-contrast focus rings and proper labeling
- Responsiveness:
  - Mobile-first layout with responsive grid that collapses to single-column cards on small screens
  - Tables should be horizontally scrollable on small viewports if needed

### Backend
- APIs to support:
  - GET /billing/subscription: Retrieve current plan, status, next billing date, usage meters, and payment method
  - GET /billing/invoices: Retrieve invoice list with pagination, date, amount, status, and download URL
  - POST /billing/change-plan: Initiate plan change with selected plan and return proration estimates
  - POST /billing/payment-method: Add or update Stripe payment method (tokenization via Stripe)
  - GET /billing/addons: List available add-ons with pricing
  - POST /billing/purchase-addon: Create checkout session or invoice for add-ons
  - POST /billing/apply-coupon: Validate and apply coupon to current or upcoming invoice
  - POST /checkout/session: Create a secure Stripe Checkout session for subscription/add-on
  - GET /billing/export: Generate exportable invoices or decision logs as PDF/CSV
- Database considerations:
  - Tables/collections for Subscriptions, Plans, Invoices, PaymentMethods, AddOns, Coupons
  - Audit fields: created_at, updated_at, last_modified_by
  - Indexes on user_id, subscription_id, invoice_date for performance
- Stripe integration:
  - Use Stripe Customer, Payment Methods, Subscriptions, Invoices as appropriate
  - Support plan proration, prorations display in Plan Change flow
  - Securely handle payment method tokens; do not store full card numbers
  - Webhook handling for invoice.payment_succeeded/failed, subscription.updated, and payment_intent.succeeded
- Validation:
  - Server-side validation for plan eligibility, add-on availability, coupon validity, and correct user ownership
  - Ensure idempotency for checkout/session creation

### Integration
- Data flow:
  - Billing page fetches user subscription and invoices from backend; UI updates with actions
  - Plan Change modal triggers backend plan-change process; reflect prorations
  - Payment Method form communicates with Stripe via backend endpoints
  - Add-ons purchase routes funnel to Checkout / Payment Page with a summary and coupon entry
  - Invoices download uses generated PDFs stored or generated on-the-fly by backend
- Connected pages integration:
  - Settings / Preferences: Billing-related settings reflect in the Billing page (billing exposure, export options)
  - Checkout / Payment Page: Central secure path for payment, shared with subscription changes and add-ons
  - Landing Page: CTAs for signup/demo will route to Checkout where appropriate or to onboarding flows

## User Experience Flow
- User signs in and lands on Billing / Subscription Page
  1. View current plan card with limits, usage meters, next billing date, and renewal status
  2. Click Change Plan to open modal; review proration details; confirm plan switch
  3. Manage Payment Method:
     - Open Payment Method section; add/update card via Stripe; set default payment method
     - See masked card details and last4; confirm changes
  4. Invoices:
     - Browse list; view details; download PDF invoices; filter by date/status
  5. Add-ons:
     - Review available add-ons; click Buy to open Checkout flow
     - In Checkout, review order summary, apply coupon, complete secure payment
  6. Exit or continue to export data if needed (PDF/CSV)
- Edge cases:
  - Failed payments: show actionable error, allow update of payment method
  - Proration explanations: clearly present impact when upgrading/downgrading mid-cycle
  - Coupon invalid/expired: display friendly error with guidance
  - Add-on out-of-stock or unavailable: gracefully handle and provide alternatives

## Technical Specifications

Data Models:
- User
- Subscription: { id, user_id, plan_id, status, current_period_start, current_period_end, next_billing_date, quantity, trial_period_end, prorated_amount }
- Plan: { id, name, price, interval (monthly/yearly), features, limits: { usage, seats, storage }, is_active }
- Invoice: { id, subscription_id, invoice_date, amount_due, currency, status, pdf_url, pdf_generated_at }
- PaymentMethod: { id, user_id, stripe_payment_method_id, brand, last4, exp_month, exp_year, is_default }
- AddOn: { id, name, description, price, currency, interval, features }
- Coupon: { id, code, discount_type, amount_off, percent_off, valid_until, applies_to_plan_ids, max_uses }

API Endpoints (examples):
- GET /api/billing/subscription
- GET /api/billing/invoices?page=&limit=&status=
- POST /api/billing/change-plan
- POST /api/billing/payment-method
- GET /api/billing/addons
- POST /api/billing/purchase-addon
- POST /api/billing/apply-coupon
- POST /api/checkout/session
- GET /api/billing/export

Security:
- Authentication: JWT or session-based auth; require valid user token
- Authorization: Ensure user owns the subscription and invoices
- PCI compliance: Stripe handles card data; never store full card numbers
- Webhooks: Validate Stripe webhook signatures; idempotent processing

Validation:
- Frontend: required fields; format checks; valid coupon codes; date picks; numeric inputs
- Backend: verify user ownership; validate plan compatibility; ensure coupon validity; idempotent operations for checkout

## Acceptance Criteria
- [ ] Billing / Subscription Page loads with current plan, next billing date, usage meters, and a list of invoices
- [ ] Change Plan flow shows prorations; selecting a plan updates the subscription via backend and reflects in UI
- [ ] Payment Method management supports adding/updating Stripe card, with default indicator and secure storage
- [ ] Invoices table displays all invoices with date, amount, status, and downloadable PDF; pagination/search/sort works
- [ ] Add-ons catalog loads; purchasing an add-on redirects to Checkout and completes payment securely
- [ ] Checkout / Payment Page handles subscription and add-ons with order summary, coupon entry, and Stripe payment collection
- [ ] Webhook handling for payment events updates internal records accordingly
- [ ] Accessibility and responsive behavior meet WCAG 2.1 AA standards
- [ ] UI aligns with the design system: colors, typography, cards, shadows, spacing

## UI/UX Guidelines
Apply the project's design system:
- Cards with white background, subtle shadows, 12–16px radii
- Top navigation and secondary navigation consistent with Archject
- Pill-shaped primary actions in deep green
- Soft, readable typography with Inter/SF Pro/Manrope-like font
- Left-aligned content, generous whitespace, consistent 8px spacing increments
- Hover/focus states: elevation, color shifts, focus rings
- Data visualization notes: if charts appear (usage/meters), use clean lines and muted axes

## Visual Style

 Color Palette (as provided):
- Primary: Soft white (#FFFFFF)
- Secondary: Very light gray (#F5F6FA, #F7F8FA)
- Accent Colors:
  - Deep green (#195C4A) for active navigation and primary actions
  - Bright green (#7BE495) for success indicators
  - Soft yellow (#FFE8A3) and muted orange (#FFDCA8) for warnings/in-progress
  - Light red (#FF6C6C) for destructive actions and overdue
- Text:
  - Dark gray (#23272F)
  - Medium gray (#6B7280)
- Subtle borders/shadows: #E6E8F0, #D1D5DB
- Typography:
  - Font family: Inter / SF Pro / Manrope-like
  - Weights: 400 body, 500 labels/navigation, 600 headings/actions
- Layout: 24–32px container padding; 16–24px gaps; 8px increments
- Card styling: white background, soft box shadow (0 4px 16px rgba(34, 42, 89, 0.05)), 12–16px radius
- Interaction: hover elevations, color shifts, focus rings

Design Philosophy:
- Modern, minimal, professional; accessible and intuitive
- Clear hierarchy, trust, and data ownership
- Mobile-first, responsive, and distraction-free surfaces

Connected Pages/Features:
- Settings / Preferences: Billing-related settings, branding, integrations, API keys, data export
- Landing Page: Marketing content with pricing and CTAs
- Checkout / Payment Page: Secure checkout flow for subscriptions/add-ons

Notes for AI development tool:
- Model should generate code scaffolds, components, and API contracts aligned to the specified structures.
- Include data mocks and example API payloads for testing.
- Provide clear separation between frontend components and backend API definitions, with type definitions (e.g., TypeScript interfaces) and API schema (OpenAPI-like) as outputs.
- Produce a structured repo layout suggestion (folders for frontend pages, components, hooks, services, and backend routes/controllers).
- Include unit tests stubs for key components and integration tests outline for end-to-end flows with Stripe simulation.

Generated deliverable should include:
- Detailed UI component specs and wireframes (descriptions sufficient for implementation)
- API contracts with request/response schemas
- Frontend component tree and state management plan
- Backend service/module outlines with data models and Stripe integration steps
- Access control and security notes
- Acceptance test plan with concrete test cases and expected outcomes

If you need me to tailor to a specific frontend framework (e.g., React + Next.js) or a backend stack (e.g., Node/Express, NestJS, or Python FastAPI), I can adapt the prompt with precise code scaffolding and file templates.

=== SUCCESS CRITERIA ===
# Success Criteria Checklist

## Code Quality

### TypeScript
- [ ] No TypeScript errors (`tsc --noEmit` passes)
- [ ] All functions and components have proper type definitions
- [ ] No `any` types used (use `unknown` if type is truly unknown)
- [ ] Props interfaces defined for all components
- [ ] API responses have type definitions

### Code Standards
- [ ] All imports use path aliases (@/ prefix)
- [ ] Components follow the established naming convention
- [ ] Files are organized in correct directories
- [ ] No unused imports or variables
- [ ] Consistent code formatting

## Component Implementation

### UI Components
- [ ] Use shadcn/ui components (Button, Card, Input, etc.) instead of building from scratch
- [ ] All interactive elements have hover states
- [ ] Components use the `cn()` utility for class merging
- [ ] Proper TypeScript props interfaces defined
- [ ] Components are responsive (mobile, tablet, desktop)

### Animations
- [ ] Motion library used for all animations (NOT framer-motion)
- [ ] Page transitions implemented with fade/slide
- [ ] Interactive elements have whileHover/whileTap animations
- [ ] List items use stagger animations where appropriate
- [ ] Animations respect `prefers-reduced-motion`

### Icons
- [ ] Lucide React icons used consistently
- [ ] Icons have consistent sizing (h-4 w-4, h-5 w-5, h-6 w-6)
- [ ] Icon colors match design system (text-primary, text-muted-foreground)

## Data Management

### React Query
- [ ] All data fetching uses React Query hooks
- [ ] Query keys follow the established pattern
- [ ] Mutations invalidate related queries
- [ ] Loading and error states handled
- [ ] Optimistic updates implemented where appropriate

### Forms
- [ ] Forms use react-hook-form
- [ ] Validation uses Zod schemas
- [ ] Error messages display properly
- [ ] Form submission shows loading state
- [ ] Success/error feedback via toast notifications

### API Layer
- [ ] API functions in src/api/ directory
- [ ] Axios used for HTTP requests
- [ ] Proper error handling with try/catch
- [ ] Auth tokens handled by interceptors
- [ ] Type-safe API function signatures

## User Experience

### Notifications
- [ ] Sonner toasts used for all notifications
- [ ] Success actions show success toast
- [ ] Errors show descriptive error messages
- [ ] Loading states show toast.loading()

### Loading States
- [ ] Skeleton loaders shown during data fetch
- [ ] Buttons show loading state during submission
- [ ] Disabled state applied during async operations

### Error Handling
- [ ] Network errors caught and displayed
- [ ] User-friendly error messages (no stack traces)
- [ ] Fallback UI for error states
- [ ] No unhandled promise rejections

## Navigation

### Route Accessibility
- [ ] All pages have routes defined in router configuration
- [ ] Every page is accessible through navigation (menu, sidebar, or direct URL)
- [ ] Main pages (Dashboard, Home, Settings, etc.) accessible from primary navigation
- [ ] Secondary pages accessible through contextual navigation or direct links
- [ ] Deep-linked pages have breadcrumbs or back navigation
- [ ] 404/Not Found page implemented for invalid routes
- [ ] Protected routes have proper authentication checks
- [ ] Navigation state persists across page refreshes where appropriate

### Navigation UX
- [ ] Active route highlighted in navigation menu
- [ ] Clear visual hierarchy in navigation structure
- [ ] Mobile navigation is accessible and usable
- [ ] Navigation items have hover/focus states
- [ ] Nested routes show parent-child relationships
- [ ] User can always return to main areas (Dashboard/Home)

## Styling

### Tailwind CSS
- [ ] Tailwind v3 classes used
- [ ] HSL color variables from design system
- [ ] Custom CSS properties used where defined
- [ ] Responsive breakpoints: mobile-first approach
- [ ] Dark mode support via CSS variables

### Design System
- [ ] Colors use theme variables (primary, secondary, accent)
- [ ] Spacing uses Tailwind scale (p-4, gap-6, etc.)
- [ ] Border radius uses theme values (rounded-lg)
- [ ] Shadows use theme values (shadow-card)
- [ ] Typography follows Inter font system

## Accessibility

- [ ] Semantic HTML elements used
- [ ] Buttons have descriptive labels
- [ ] Forms have proper labels
- [ ] Focus states visible on interactive elements
- [ ] Color contrast meets WCAG standards

## Performance

- [ ] No console.log statements in production code
- [ ] No console errors in browser
- [ ] Images optimized (WebP, lazy loading)
- [ ] Large lists use virtualization if needed
- [ ] React Query cache configured appropriately

## Testing Readiness

- [ ] Components structured for easy testing
- [ ] Business logic separated from presentation
- [ ] Mock-friendly API layer
- [ ] No hardcoded values that should be configurable
- [ ] Environment variables properly configured

## Final Checks

- [ ] Code builds without errors (`npm run build`)
- [ ] Development server runs without errors (`npm run dev`)
- [ ] No TypeScript errors in editor
- [ ] Browser console is clean (no errors or warnings)
- [ ] All functionality works as expected
- [ ] Code follows existing project patterns
- [ ] Changes are consistent with the rest of the codebase



IMPORTANT: ALL styling and design decisions must follow the Design Reference section above EXACTLY. Do not make arbitrary design choices.

Analyze the existing project structure and implement the task following the patterns already established. Ensure all success criteria are met.